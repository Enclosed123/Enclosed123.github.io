[{"title":"Vue代理proxyTable设置","date":"2019-12-26T09:40:01.198Z","path":"2019/12/26/Vue代理proxyTable设置/","text":"Vue 代理 proxyTable 设置背景：vue项目在本地开发默认打开localhost:8081，但是后端请求地址和本地产生跨域，怎样快速的在本地进行调接口调试？vue-cli自带的proxyTable 可以解决本地开发跨域问题 我们在项目中的后端路由，都带有 /server/ 的prefix 那么我们在config里配置 proxyTable 可以这样写： 123456789proxyTable: &#123; &#39;&#x2F;server&#39;: &#123; target: &#39;http:&#x2F;&#x2F;后端地址:7002&#39;, changeOrigin: true, pathRewrite: &#123; &#39;&#x2F;server&#39;: &#39;&#x2F;server&#x2F;&#39; &#125; &#125; &#125;, 这样本地就可以调用后端的接口进行调试了，记住，改完config文件要重新npm run dev ps：此方法仅限用于开发环境，不适合生产环境，生产环境可以用nginx进行代理","tags":[]},{"title":"JavaScript执行机制","date":"2019-12-26T09:35:01.855Z","path":"2019/12/26/JavaScript执行机制/","text":"1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data &#x3D; [];$.ajax(&#123; url:www.javascript.com, data:data, success:() &#x3D;&gt; &#123; console.log(&#39;发送成功!&#39;); &#125;&#125;)console.log(&#39;代码执行结束&#39;); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行： 123setTimeout(() &#x3D;&gt; &#123; console.log(&#39;延时3秒&#39;);&#125;,3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子： 1234setTimeout(() &#x3D;&gt; &#123; task();&#125;,3000)console.log(&#39;执行console&#39;); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12&#x2F;&#x2F;执行console&#x2F;&#x2F;task() 去验证一下，结果正确！然后我们修改一下前面的代码： 12345setTimeout(() &#x3D;&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 12345678910&#x2F;&#x2F;代码1console.log(&#39;先执行这里&#39;);setTimeout(() &#x3D;&gt; &#123; console.log(&#39;执行啦&#39;)&#125;,0);&#x2F;&#x2F;代码2console.log(&#39;先执行这里&#39;);setTimeout(() &#x3D;&gt; &#123; console.log(&#39;执行啦&#39;)&#125;,3000); 代码1的输出结果是： 12&#x2F;&#x2F;先执行这里&#x2F;&#x2F;执行啦 代码2的输出结果是： 123&#x2F;&#x2F;先执行这里&#x2F;&#x2F; ... 3s later&#x2F;&#x2F; 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log(&#39;setTimeout&#39;);&#125;)new Promise(function(resolve) &#123; console.log(&#39;promise&#39;);&#125;).then(function() &#123; console.log(&#39;then&#39;);&#125;)console.log(&#39;console&#39;); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 事件循环，宏任务，微任务的关系如图所示： 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log(&#39;1&#39;);setTimeout(function() &#123; console.log(&#39;2&#39;); process.nextTick(function() &#123; console.log(&#39;3&#39;); &#125;) new Promise(function(resolve) &#123; console.log(&#39;4&#39;); resolve(); &#125;).then(function() &#123; console.log(&#39;5&#39;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&#39;6&#39;);&#125;)new Promise(function(resolve) &#123; console.log(&#39;7&#39;); resolve();&#125;).then(function() &#123; console.log(&#39;8&#39;)&#125;)setTimeout(function() &#123; console.log(&#39;9&#39;); process.nextTick(function() &#123; console.log(&#39;10&#39;); &#125;) new Promise(function(resolve) &#123; console.log(&#39;11&#39;); resolve(); &#125;).then(function() &#123; console.log(&#39;12&#39;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后 javascript是一门单线程语言 Event Loop是javascript的执行机制","tags":[]},{"title":"项目常用JS方法封装","date":"2019-12-26T09:27:13.336Z","path":"2019/12/26/项目常用JS方法封装/","text":"001.输入一个值,返回其数据类型1234type &#x3D; para &#x3D;&gt; &#123; return Object.prototype.toString.call(para).slice(8,-1) &#125;qwe 002.冒泡排序升序 bubbleAsSort() 12345678910111213bubbleAsSort &#x3D; arr &#x3D;&gt; &#123; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; for (let j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp &#x3D; arr[j + 1]; arr[j + 1] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125; &#125; return arr;&#125;qwe 降序 bubbleDeSort() 12345678910111213bubbleDeSort &#x3D; arr &#x3D;&gt; &#123; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; for (let j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; let temp &#x3D; arr[j + 1]; arr[j + 1] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125; &#125; return arr;&#125;qwe 003.选择排序升序 selectAsSort() 12345678910111213141516selectAsSort &#x3D; arr &#x3D;&gt; &#123; let minIndex, temp; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; minIndex &#x3D; i; for (let j &#x3D; i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex &#x3D; j; &#125; &#125; temp &#x3D; arr[i]; arr[i] &#x3D; arr[minIndex]; arr[minIndex] &#x3D; temp; &#125; return arr;&#125;qwe 降序 selectDeSort() 12345678910111213141516selectDeSort &#x3D; arr &#x3D;&gt; &#123; let minIndex, temp; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; minIndex &#x3D; i; for (let j &#x3D; i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &gt; arr[minIndex]) &#123; minIndex &#x3D; j; &#125; &#125; temp &#x3D; arr[i]; arr[i] &#x3D; arr[minIndex]; arr[minIndex] &#x3D; temp; &#125; return arr;&#125;qwe 004.插入排序升序 insertAsSort() 1234567891011121314insertAsSort &#x3D; arr &#x3D;&gt; &#123; let current, preIndex; for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; current &#x3D; arr[i]; preIndex &#x3D; i - 1; while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] &#x3D; arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] &#x3D; current; &#125; return arr;&#125;qwe 降序 insertDeSort() 1234567891011121314insertDeSort &#x3D; arr &#x3D;&gt; &#123; let current, preIndex; for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; current &#x3D; arr[i]; preIndex &#x3D; i - 1; while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &lt; current) &#123; arr[preIndex + 1] &#x3D; arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] &#x3D; current; &#125; return arr;&#125;qwe 005.阶乘12345678factorial &#x3D; num &#x3D;&gt; &#123; let count &#x3D; 1; for (let i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; count *&#x3D; i; &#125; return count;&#125;qwe 006.两个数之间累乘12345678910111213141516multBetride &#x3D; (x, y) &#x3D;&gt; &#123; let count; if (x &lt; y) &#123; count &#x3D; x; for (let i &#x3D; x + 1; i &lt;&#x3D; y; i++) &#123; count *&#x3D; i; &#125; return count; &#125; else &#123; count &#x3D; y; for (let i &#x3D; y + 1; i &lt;&#x3D; x; i++) &#123; count *&#x3D; i; &#125; return count; &#125;&#125; 007.累加（）里面可以放N个实参 1234567function cumsum() &#123; let sum &#x3D; 0; for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123; sum +&#x3D; arguments[i]; &#125; return sum;&#125; 008.计时器(计算代码块(函数)执行时间)无参 computeTime(f) 1234567computeTime &#x3D; code &#x3D;&gt; &#123; let startTime &#x3D; new Date().getTime(); code(); let endTime &#x3D; new Date().getTime(); let time &#x3D; endTime - startTime; return time;&#125; 有参 computeTime(f) 使用方法:computeTime(f,参数1,参数2……) 1234567891011computeTime &#x3D; f &#x3D;&gt; &#123; let startTime &#x3D; new Date().getTime(); let p &#x3D; []; for (let i &#x3D; 1; i &lt; arguments.length; i++) &#123; p.push(arguments[i]) &#125; f.apply(null, p) let endTime &#x3D; new Date().getTime(); let Time &#x3D; endTime - startTime; return Time;&#125; 009.数组去重12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152arrDemp1 &#x3D; arr &#x3D;&gt; &#123; let newArr &#x3D; []; let m &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; let n &#x3D; arr[i]; if (m[n]) &#123; &#125; else &#123; newArr.push(arr[i]); m[n] &#x3D; true; &#125; &#125; return newArr;&#125;&#x2F;&#x2F;遍历数组法arrDemp2 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F;indexOf()方法可返回某个指定的字符串或数组值在字符串或数组中首次出现的位置，若不在其中则返回-1 if (temp.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) temp.push(arr[i]); &#125; return temp;&#125;&#x2F;&#x2F;排序法arrDemp3 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; arr.sort(); temp.push(arr[0]); &#x2F;&#x2F;因为数组已经经过排序，所以重复元素一定相邻，判断当前数组第i个元素与temp的最后一个元素是否相等，不相等时才复制元素 for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; if (arr[i] !&#x3D; temp[temp.length - 1]) temp.push(arr[i]); &#125; return temp;&#125;&#x2F;&#x2F;对象法arrDemp4 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; let json &#x3D; &#123;&#125;; &#x2F;&#x2F;将当前数组的元素值当作对象的属性，遍历数组，比对对象，如果对象的这个属性不存在则将当前数组元素复制到临时数组，并添加该属性且将属性值赋值为1 for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (!json[arr[i]]) &#123;&#x2F;&#x2F;如果对象没有该属性 temp.push(arr[i]); json[arr[i]] &#x3D; 1;&#x2F;&#x2F;添加属性，将属性值赋值为1 &#125; &#125; return temp;&#125; 也可以使用ES6中的new Set，一步到位 1234let arr &#x3D; [1,2,3,5,4,5,4,3,6]let arrDemp &#x3D; new Set(arr) &#x2F;&#x2F;arrDemp是一个对象let newArr &#x3D; [...arrDemp] &#x2F;&#x2F;把arrDemp转化成数组console.log(newArr); 010.数组对象去重将对象数组中属性相同的项去重 1234567891011121314151617181920212223242526272829303132333435&#x2F;** objArr 对象数组* para 将要进行去重的字段(String类型)*&#x2F;测试数据：let objArr &#x3D; [&#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;a&#39;, age: 2 &#125;, &#123; name: &#39;b&#39;, age: 2 &#125;]console.log(objArrDemp1(objArr,&#39;name&#39;)); &#x2F;&#x2F; [ &#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;b&#39;, age: 2 &#125; ]console.log(objArrDemp1(objArr,&#39;age&#39;)); &#x2F;&#x2F; [ &#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;a&#39;, age: 2 &#125; ]objArrDemp1 &#x3D; (objArr, para) &#x3D;&gt; &#123; let result &#x3D; []; let temp &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; objArr.length; i++) &#123; let parameter &#x3D; objArr[i][para]; if (temp[parameter]) &#123; continue;&#x2F;&#x2F;不继续执行接下来的代码，跳转至循环开头 &#125; temp[parameter] &#x3D; true;&#x2F;&#x2F;为temp添加此属性（parameter）且将其值赋为true result.push(objArr[i]);&#x2F;&#x2F;将这一项复制到结果数组result中去 &#125; return result;&#125;objArrDemp2 &#x3D; (objArr, para) &#x3D;&gt; &#123; let hash &#x3D; &#123;&#125;; &#x2F;&#x2F;reduce方法有两个参数，第一个参数是一个callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。 objArr &#x3D; objArr.reduce(function (item, next) &#123;&#x2F;&#x2F;这是针对数组项操作的函数，对于每个数组项，reduce方法都会将其调用一次 hash[next[para]] ? &#39;&#39; : hash[next[para]] &#x3D; true &amp;&amp; item.push(next); return item; &#125;, []);&#x2F;&#x2F;初始值是一个空对象，使用reduce方法返回的是空对象通过叠加执行之后的结果 return objArr;&#125; 011.统计数组中各个元素出现的次数12345678910111213141516staArrNum &#x3D; arr &#x3D;&gt; &#123; let obj &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; let m &#x3D; arr[i]; if (obj.hasOwnProperty(m)) &#123; obj[m] +&#x3D; 1; &#125; else &#123; obj[m] &#x3D; 1; &#125; &#125; return obj;&#125;let arr &#x3D; [1, 2, 3, 6, 5, 3, 2, 1, 2, 3, 2, 1]console.log(staArrNum(arr)); &#x2F;&#x2F; &#123; &#39;1&#39;: 3, &#39;2&#39;: 4, &#39;3&#39;: 3, &#39;5&#39;: 1, &#39;6&#39;: 1 &#125; 012.在数组中找指定的元素,返回下标12345678910111213arrFinNum &#x3D; function (arr,num) &#123; let index &#x3D; -1; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (num &#x3D;&#x3D; arr[i]) &#123; index &#x3D; i; break; &#125; &#125; return index;&#125;let arr &#x3D; [1,2,3,4,5,6]console.log(arrFinNum(arr,4)); &#x2F;&#x2F; 3 013.删除数组中的元素123456delArrNum &#x3D; (arr,val) &#x3D;&gt; &#123; let index &#x3D; arrFinNum(arr, val) &#x2F;&#x2F;调用了前面自行添加的arrFinNum方法 if (index !&#x3D; -1) &#123; return arr.splice(index, 1); &#125;&#125; 示例 123456789101112131415161718192021let arr &#x3D; [1, 2, 3, 4, 5, 6]arrFinNum &#x3D; (arr, num) &#x3D;&gt; &#123; let index &#x3D; -1; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (num &#x3D;&#x3D; arr[i]) &#123; index &#x3D; i; break; &#125; &#125; return index;&#125;delArrNum &#x3D; (arr,val) &#x3D;&gt; &#123; let index &#x3D; arrFinNum(arr, val) &#x2F;&#x2F;调用了前面自行添加的arrFinNum方法 if (index !&#x3D; -1) &#123; return arr.splice(index, 1); &#125;&#125;console.log(delArrNum(arr,2)); &#x2F;&#x2F; [ 2 ] 014.数字超过9显示省略号12345678num_filter &#x3D; val &#x3D;&gt;&#123; val &#x3D; val?val-0:0; if (val &gt; 9 ) &#123; return &quot;…&quot; &#125;else&#123; return val; &#125;&#125; 015.数字超过99显示99+12345678ninenum_filter &#x3D; val &#x3D;&gt;&#123; val &#x3D; val?val-0:0; if (val &gt; 99 ) &#123; return &quot;99+&quot; &#125;else&#123; return val; &#125;&#125; 016.银行卡号分割12345bank_filter &#x3D; val &#x3D;&gt;&#123; val +&#x3D; &#39;&#39;; val &#x3D; val.replace(&#x2F;(\\s)&#x2F;g,&#39;&#39;).replace(&#x2F;(\\d&#123;4&#125;)&#x2F;g,&#39;$1 &#39;).replace(&#x2F;\\s*$&#x2F;,&#39;&#39;); return val;&#125; 017.二分查找1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F;非递归实现binarySearch &#x3D; (arr, key) &#x3D;&gt; &#123; let high &#x3D; arr.length - 1, low &#x3D; 0; while (low &lt;&#x3D; high) &#123; let m &#x3D; Math.floor((high + low) &#x2F; 2); if (arr[m] &#x3D;&#x3D; key) &#123; return m; &#125; if (key &gt; arr[m]) &#123; low &#x3D; m + 1; &#125; else &#123; high &#x3D; m - 1; &#125; &#125; return false;&#125;let arr &#x3D; [-1, 1, 3, 4, 5, 8, 32, 234, 12, 42];console.log(binarySearch(arr, 4));&#x2F;&#x2F;递归实现binarySearch &#x3D; (arr, low, high, key) &#x3D;&gt; &#123; if (low &gt; high) &#123; return -1; &#125; let mid &#x3D; parseInt((high + low) &#x2F; 2); if (arr[mid] &#x3D;&#x3D; key) &#123; return mid; &#125; else if (arr[mid] &gt; key) &#123; high &#x3D; mid - 1; return binarySearch(arr, low, high, key); &#125; else if (arr[mid] &lt; key) &#123; low &#x3D; mid + 1; return binarySearch(arr, low, high, key); &#125;&#125;;let arr &#x3D; [-1, 1, 3, 4, 5, 8, 32, 234, 12, 42];console.log(binarySearch(arr, 0, 13, 5)); 018.防抖与节流123456789101112131415161718192021222324252627282930313233343536373839&#x2F;** * 函数防抖 (只执行最后一次点击) *&#x2F;Debounce &#x3D; (fn, t) &#x3D;&gt; &#123; let delay &#x3D; t || 500; let timer; return function () &#123; let args &#x3D; arguments; if(timer)&#123; clearTimeout(timer); &#125; timer &#x3D; setTimeout(() &#x3D;&gt; &#123; timer &#x3D; null; fn.apply(this, args); &#125;, delay); &#125;&#125;;&#x2F;* * 函数节流 *&#x2F;Throttle &#x3D; (fn, t) &#x3D;&gt; &#123; let last; let timer; let interval &#x3D; t || 500; return function () &#123; let args &#x3D; arguments; let now &#x3D; +new Date(); if (last &amp;&amp; now - last &lt; interval) &#123; clearTimeout(timer); timer &#x3D; setTimeout(() &#x3D;&gt; &#123; last &#x3D; now; fn.apply(this, args); &#125;, interval); &#125; else &#123; last &#x3D; now; fn.apply(this, args); &#125; &#125;&#125;; 019.深拷贝1234567891011121314151617181920212223242526272829deepClone &#x3D; source &#x3D;&gt; &#123; const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;; &#x2F;&#x2F; 判断复制的目标是数组还是对象 for (let keys in source) &#123; &#x2F;&#x2F; 遍历目标 if (source.hasOwnProperty(keys)) &#123; if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123; &#x2F;&#x2F; 如果值是对象，就递归一下 targetObj[keys] &#x3D; source[keys].constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;; targetObj[keys] &#x3D; deepClone(source[keys]); &#125; else &#123; &#x2F;&#x2F; 如果不是，就直接赋值 targetObj[keys] &#x3D; source[keys]; &#125; &#125; &#125; return targetObj;&#125;let str1 &#x3D; &#123; arr: [1, 2, 3], obj: &#123; key: &#39;value&#39; &#125;, fn: function () &#123; return 1; &#125;&#125;;let str3 &#x3D; deepClone(str1);console.log(str3 &#x3D;&#x3D;&#x3D; str1); &#x2F;&#x2F; falseconsole.log(str3.obj &#x3D;&#x3D;&#x3D; str1.obj); &#x2F;&#x2F; falseconsole.log(str3.fn &#x3D;&#x3D;&#x3D; str1.fn); &#x2F;&#x2F; true 020.获取视口尺寸需要在HTML文件中运行 1234567891011121314151617181920212223function getViewportOffset() &#123; if (window.innerWidth) &#123; return &#123; w: window.innerWidth, h: window.innerHeight &#125; &#125; else &#123; &#x2F;&#x2F; ie8及其以下 if (document.compatMode &#x3D;&#x3D;&#x3D; &quot;BackCompat&quot;) &#123; &#x2F;&#x2F; 怪异模式 return &#123; w: document.body.clientWidth, h: document.body.clientHeight &#125; &#125; else &#123; &#x2F;&#x2F; 标准模式 return &#123; w: document.documentElement.clientWidth, h: document.documentElement.clientHeight &#125; &#125; &#125;&#125; 021.数字前补零1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;*** num为你想要进行填充的数字* length为你想要的数字长度*&#x2F;&#x2F;&#x2F;迭代方式实现padding1&#x3D;(num, length)&#x3D;&gt; &#123; for(let len &#x3D; (num + &quot;&quot;).length; len &lt; length; len &#x3D; num.length) &#123; num &#x3D; &quot;0&quot; + num; &#125; return num;&#125;&#x2F;&#x2F;递归方式实现padding2&#x3D;(num, length) &#x3D;&gt;&#123; if((num + &quot;&quot;).length &gt;&#x3D; length) &#123; return num; &#125; return padding2(&quot;0&quot; + num, length)&#125;&#x2F;&#x2F;转为小数padding3&#x3D;(num, length)&#x3D;&gt; &#123; let decimal &#x3D; num &#x2F; Math.pow(10, length); &#x2F;&#x2F;toFixed指定保留几位小数 decimal &#x3D; decimal.toFixed(length) + &quot;&quot;; return decimal.substr(decimal.indexOf(&quot;.&quot;)+1);&#125;&#x2F;&#x2F;填充截取法padding4&#x3D;(num, length)&#x3D;&gt; &#123; &#x2F;&#x2F;这里用slice和substr均可 return (Array(length).join(&quot;0&quot;) + num).slice(-length);&#125;&#x2F;&#x2F;填充截取法padding5&#x3D;(num, length)&#x3D;&gt; &#123; let len &#x3D; (num + &quot;&quot;).length; let diff &#x3D; length+1 - len; if(diff &gt; 0) &#123; return Array(diff).join(&quot;0&quot;) + num; &#125; return num;&#125; 022.字符替换可以替换任意数字和符号 12345678910111213&#x2F;*** str 表示将要替换的字符串* l 表示你将要替换的字符* r 表示你想要替换的字符*&#x2F;transFormat &#x3D; (str, l, r) &#x3D;&gt; &#123; let reg &#x3D; new RegExp(l, &#39;g&#39;) &#x2F;&#x2F; g表示全部替换，默认替换第一个 str &#x3D; str.replace(reg, r) return str&#125;console.log(transFormat(&#39;2019-12-13&#39;, &#39;-&#39;, &#39;&#x2F;&#39;)); &#x2F;&#x2F; 2019&#x2F;12&#x2F;13console.log(transFormat(&#39;2019-12-13&#39;, &#39;-&#39;, &#39;&#39;)); &#x2F;&#x2F; 20191213 023.在字符串指定位置插入字符1234567891011&#x2F;*** character 原字符串（String）* site 要插入的字符的位置 （Number）* newStr 想要插入的字符 （String）*&#x2F;insertStr &#x3D; (character, site, newStr) &#x3D;&gt; &#123; return character.slice(0, site) + newStr + character.slice(site);&#125;console.log(insertStr(&#39;20191217&#39;,4,&#39;-&#39;)); &#x2F;&#x2F; 2019-1217 024.字符串反转处理分割123456789101112&#x2F;*** str 是你将要进行处理的字符串(String)* under 是你根据什么字符处理(String)* event 是你根据什么字符把处理结果分割(String)*&#x2F;keyCharacterMap &#x3D; (str,under,event) &#x3D;&gt; &#123; return str.split(under).reverse().join(event)&#125;console.log(keyCharacterMap(&#39;hello world&#39;,&#39;&#39;,&#39;&#39;)); &#x2F;&#x2F; dlrow ollehconsole.log(keyCharacterMap(&#39;hello world&#39;,&#39; &#39;,&#39;-&#39;)); &#x2F;&#x2F; world-hello 025.格式转换：base64转file1234567891011121314151617&#x2F;*** base64 base64* filename 转换后的文件名*&#x2F;base64ToFile &#x3D; (base64, filename) &#x3D;&gt; &#123; let arr &#x3D; base64.split(&quot;,&quot;), mime &#x3D; arr[0].match(&#x2F;:(.*?);&#x2F;)[1], bstr &#x3D; atob(arr[1]), n &#x3D; bstr.length, u8arr &#x3D; new Uint8Array(n); while (n--) &#123; u8arr[n] &#x3D; bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123; type: mime &#125;);&#125; 026.格式转换：base64转blob1234567891011base64ToBlob &#x3D; base64 &#x3D;&gt; &#123; let arr &#x3D; base64.split(&#39;,&#39;), mime &#x3D; arr[0].match(&#x2F;:(.*?);&#x2F;)[1], bstr &#x3D; atob(arr[1]), n &#x3D; bstr.length, u8arr &#x3D; new Uint8Array(n); while (n--) &#123; u8arr[n] &#x3D; bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123; type: mime &#125;);&#125;; 027.格式转换：blob转file12345blobToFile &#x3D; (blob, fileName) &#x3D;&gt; &#123; blob.lastModifiedDate &#x3D; new Date(); blob.name &#x3D; fileName; return blob;&#125;;","tags":[]},{"title":"css基础","date":"2019-12-26T09:18:59.966Z","path":"2019/12/26/css基础/","text":"一、CSS盒模型 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距margin，边框border，填充padding，和实际内容content。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 box-sizing: content-box（W3C盒模型，又名标准盒模型）：元素的宽高大小表现为内容的大小。 box-sizing: border-box（IE盒模型，又名怪异盒模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。 CSS3的新特性 word-wrap 文字换行 text-overflow 超过指定容器的边界时如何显示 text-decoration 文字渲染 text-shadow文字阴影 gradient渐变效果 transition过渡效果 transition-duration：过渡的持续时间 transform拉伸，压缩，旋转，偏移等变换 animation动画 transition和animation的区别： Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。 CSS选择器及其优先级 !important 内联样式style=”” ID选择器#id 类选择器/属性选择器/伪类选择器.class.active[href=””] 元素选择器/关系选择器/伪元素选择器html+div&gt;span::after 通配符选择器* BFCBFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 BFC应用 防止margin重叠 清除内部浮动 自适应两（多）栏布局 防止字体环绕 触发BFC条件 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute、fixed BFC的特性 内部的Box会在垂直方向上一个接一个的放置。 垂直方向上的距离由margin决定 bfc的区域不会与float的元素区域重叠。 计算bfc的高度时，浮动元素也参与计算 bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 div水平居中 行内元素 1234.parent &#123; text-align: center;&#125;复制代码 块级元素 1234.son &#123; margin: 0 auto;&#125;复制代码 flex布局 12345.parent &#123; display: flex; justify-content: center;&#125;复制代码 绝对定位定宽 1234567.son &#123; position: absolute; width: 宽度; left: 50%; margin-left: -0.5*宽度&#125;复制代码 绝对定位不定宽 123456.son &#123; position: absolute; left: 50%; transform: translate(-50%, 0);&#125;复制代码 left/right: 0 12345678.son &#123; position: absolute; width: 宽度; left: 0; right: 0; margin: 0 auto;&#125;复制代码 div垂直居中 行内元素 1234567.parent &#123; height: 高度;&#125;.son &#123; line-height: 高度;&#125;复制代码 table 12345678.parent &#123; display: table;&#125;.son &#123; display: table-cell; vertical-align: middle;&#125;复制代码 flex 12345.parent &#123; display: flex; align-items: center;&#125;复制代码 绝对定位定高 1234567.son &#123; position: absolute; top: 50%; height: 高度; margin-top: -0.5高度;&#125;复制代码 绝对定位不定高 123456.son &#123; position: absolute; top: 50%; transform: translate( 0, -50%);&#125;复制代码 top/bottom: 0; 12345678.son &#123; position: absolute; height: 高度; top: 0; bottom: 0; margin: auto 0;&#125;复制代码 绝对定位和相对定位 absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。 fixed 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。 共同点：改变行内元素的呈现方式，都脱离了文档流；不同点：absolute的”根元素“是可以设置的，fixed的“根元素”固定为浏览器窗口 flex布局采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称“项目”。 ![flex.jpeg](data:image/svg+xml;utf8,) 父元素属性 属性名 属性值 备注 display flex 定义了一个flex容器，它的直接子元素会接受这个flex环境 flex-direction row,row-reverse,column,column-reverse 决定主轴的方向 flex-wrap nowrap,wrap,wrap-reverse 如果一条轴线排不下，如何换行 flex-flow [flex-direction] , [flex-wrap] 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content flex-start,flex-end,center,space-between,space-around 设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式 align-items flex-start,flex-end,center,baseline,stretch 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式 子元素属性 属性名 属性值 备注 order [int] 默认情况下flex order会按照书写顺训呈现，可以通过order属性改变，数值小的在前面，还可以是负数。 flex-grow [number] 设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间 flex-shrink [number] 设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间 flex-basis [length], auto 设置或检索弹性盒伸缩基准值 align-self auto,flex-start,flex-end,center,baseline,stretch 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置 让元素消失visibility:hidden、display:none、z-index=-1、opacity：0 opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉 z-index=-1置于其他元素下面 清除浮动 在浮动元素后面添加 clear:both 的空 div 元素， 123456&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;clear:both&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;复制代码 给父元素添加 overflow:hidden 或者 auto 样式，触发BFC。 123456789101112&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;复制代码.container&#123; width: 300px; background-color: #aaa; overflow:hidden; zoom:1; &#x2F;*IE6*&#x2F;&#125;复制代码 使用伪元素，也是在元素末尾添加一个点并带有 clear: both 属性的元素实现的。 12345678910111213141516&lt;div class&#x3D;&quot;container clearfix&quot;&gt; &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;复制代码.clearfix&#123; zoom: 1; &#x2F;*IE6*&#x2F;&#125;.clearfix:after&#123; content: &quot;.&quot;; height: 0; clear: both; display: block; visibility: hidden;&#125;复制代码 推荐使用第三种方法，不会在页面新增div，文档结构更加清晰。 calc函数calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。 12345678910#div1 &#123; position: absolute; left: 50px; width: calc( 100% &#x2F; (100px * 2) ); &#x2F;&#x2F;兼容写法 width: -moz-calc( 100% &#x2F; (100px * 2) ); width: -webkit-calc( 100% &#x2F; (100px * 2) ); border: 1px solid black;&#125;复制代码 注意点： 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px); calc()函数支持 “+”, “-“, “*”, “/“ 运算; 对于不支持 calc() 的浏览器，整个属性值表达式将被忽略。不过我们可以对那些不支持 calc()的浏览器，使用一个固定值作为回退。 移动端remrem官方定义『The font size of the root element』，即根元素的字体大小。rem是一个相对的CSS单位，1rem等于html元素上font-size的大小。所以，我们只要设置html上font-size的大小，就可以改变1rem所代表的大小。 123456789(function () &#123; var html &#x3D; document.documentElement; function onWindowResize() &#123; html.style.fontSize &#x3D; html.getBoundingClientRect().width &#x2F; 20 + &#39;px&#39;; &#125; window.addEventListener(&#39;resize&#39;, onWindowResize); onWindowResize();&#125;)();复制代码 移动端1px一般来说，在PC端浏览器中，设备像素比（dpr）等于1，1个css像素就代表1个物理像素；但是在retina屏幕中，dpr普遍是2或3，1个css像素不再等于1个物理像素，因此比实际设计稿看起来粗不少。 伪元素+scale 12345678910111213141516171819202122&lt;style&gt; .box&#123; width: 100%; height: 1px; margin: 20px 0; position: relative; &#125; .box::after&#123; content: &#39;&#39;; position: absolute; bottom: 0; width: 100%; height: 1px; transform: scaleY(0.5); transform-origin: 0 0; background: red; &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;复制代码 border-image 123456div&#123; border-width: 1px 0px; -webkit-border-image: url(border.png) 2 0 stretch; border-image: url(border.png) 2 0 stretch;&#125;复制代码 两边宽度固定中间自适应的三栏布局圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。 圣杯布局12345678910111213141516171819202122232425262728293031&lt;style&gt;body&#123; min-width: 550px;&#125;#container&#123; padding-left: 200px; padding-right: 150px;&#125;#container .column&#123; float: left;&#125;#center&#123; width: 100%;&#125;#left&#123; width: 200px; margin-left: -100%; position: relative; right: 200px;&#125;#right&#123; width: 150px; margin-right: -150px;&#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;container&quot;&gt; &lt;div id&#x3D;&quot;center&quot; class&#x3D;&quot;column&quot;&gt;center&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;left&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;right&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;复制代码 双飞翼布局12345678910111213141516171819202122232425262728&lt;style&gt;body &#123; min-width: 500px;&#125;#container &#123; width: 100%;&#125;.column &#123; float: left;&#125;#center &#123; margin-left: 200px; margin-right: 150px;&#125;#left &#123; width: 200px; margin-left: -100%;&#125;#right &#123; width: 150px; margin-left: -150px;&#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;column&quot;&gt; &lt;div id&#x3D;&quot;center&quot;&gt;center&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;column&quot;&gt;left&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;column&quot;&gt;right&lt;&#x2F;div&gt;","tags":[]}]