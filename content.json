[{"title":"webpack性能优化","date":"2020-01-06T15:39:41.834Z","path":"2020/01/06/webpack性能优化/","text":"Webapck 性能优化上一章我们介绍了Webpack常用配置和大致优化思路，这一章节我们来看一下具体怎么优化(未完待续，大佬们可以在评论中提点意见) git地址：github.com/jxs7754/dem… 1. 构建速度优化 高版本的node和Webpack 开启多进程，加快解析、压缩速度 分包，分离基础包 利用缓存来提升二次构建速度 减少文件搜索范围 速度分析：使用speed-measure-webpack-plugin12345678const SpeedMeasureWebpackPlugin &#x3D; reqire(&#39;speed-measure-webpack-plugin&#39;);const smp &#x3D; new SeedMeasureWebpackPlugin();const webpackCofig &#x3D; smp.wrap(&#123; plugins:[ &#x2F;&#x2F; MyPlugin(), ]&#125;)复制代码 可以分析整个打包的总耗时，可以查看每个loader和plugins的耗时情况； 1.1 使用高版本的Node和Webapck V8引擎的升级优化 webpack4 默认使用更快md4 hash算法 webpacks AST 可以直接从 loader 传递给 AST，减少解析时间 使用字符串方法替代正则表达式 1.2 开启多进程thread-loader1234567891011121314151617181920&#123; module:&#123; rules: [ &#123; test: &#39;&#x2F;.js$&#x2F;&#39;, use: [ &#123; loader: &#39;thread-loader&#39;, options:&#123; workers： 3， &#125; &#125;， &#39;babel-loader&#39; ] &#125; ] &#125; &#125;复制代码 HappyPack(作者已经不再维护)1234567891011121314151617181920212223const HappyPack &#x3D; require(&#39;happypack&#39;);exports.module &#x3D; &#123; rules: [ &#123; test: &#x2F;.js$&#x2F;, &#x2F;&#x2F; 1) replace your original list of loaders with &quot;happypack&#x2F;loader&quot;: &#x2F;&#x2F; loaders: [ &#39;babel-loader?presets[]&#x3D;es2015&#39; ], use: &#39;happypack&#x2F;loader&#39;, include: [ &#x2F;* ... *&#x2F; ], exclude: [ &#x2F;* ... *&#x2F; ] &#125; ]&#125;;exports.plugins &#x3D; [ &#x2F;&#x2F; 2) create the plugin: new HappyPack(&#123; &#x2F;&#x2F; 3) re-add the loaders you replaced above in #1: loaders: [ &#39;babel-loader?presets[]&#x3D;es2015&#39; ] &#125;)];复制代码 多线程压缩1234567891011121314&#x2F;&#x2F; terser-webpack-pluginmodule.exports &#x3D; &#123; optimization: &#123; minimizer: &#123; new TerserPlugin(&#123; parallel: 4, &#125;) &#125; &#125; &#125;&#x2F;&#x2F; 下面这俩个插件可以配置多线程&#x2F;&#x2F; parallel-uglify-plugin &#x2F;&#x2F; uglifyjs-webpack-plugin 复制代码 1.3 分包 设置Externals,使用 html-webpack-externals-plugin将基础包（vue vue-router）通过CDN，不打入包中。 123456789101112131415new HtmlWebpackExternalsPlugin(&#123; externals: [ &#123; module: &#39;react&#39;, entry: &#39;https:&#x2F;&#x2F;xxx&#x2F;react.min.js&#39;, global: &#39;React&#39;, &#125;, &#123; module: &#39;react-dom&#39;, entry: &#39;https:&#x2F;&#x2F;xxx&#x2F;react-dom.min.js&#39;, global: &#39;ReactDOM&#39;, &#125;, ],&#125;),复制代码 没有CDN的情况 可以预编译 DllPlugin进行分包，DllReferencePlugin对manifest.json 引用 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 分包module.exports &#x3D; &#123; mode: &#39;production&#39;, entry: &#123; vue: [&#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;, &#39;vue-router&#39;, &#39;vuex&#39;], axios: [&#39;axios&#39;, &#39;qs&#39;], &#x2F;&#x2F; ui: [&#39;element-ui&#39;], &#125;, output: &#123; filename: &#39;[name]_[chunkhash:8].dll.js&#39;, path: path.join(__dirname, &#39;build&#39;), library: &#39;[name]&#39;, &#125;, plugins: [ new CleanWebpackPlugin(), new webpack.DllPlugin(&#123; name: &#39;[name]_[hash]&#39;, path: path.join(__dirname, &#39;build&#x2F;[name].json&#39;), &#125;), ],&#125;;&#x2F;&#x2F; 引用module.exports &#x3D; &#123; plugins: [ ...[&#39;vue&#39;, &#39;axios&#39;].map((item) &#x3D;&gt; new webpack.DllReferencePlugin(&#123; context: path.join(__dirname, &#39;.&#x2F;build&#39;), manifest: require(&#96;.&#x2F;build&#x2F;$&#123;item&#125;.json&#96;), &#125;)), ] &#125;复制代码 1.4 缓存 缓存是为了二次构建时候，加快构建 babel-loader 开启缓存1234567&#123; loader: &#39;babel-loader&#39;, options:&#123; cacheDirectory: true &#125;&#125; 复制代码 terser-webpack-plugin 开启缓存12345678910111213&#123; optimization: &#123; minimizer: &#123; new TerserPlugin(&#123; &#x2F;&#x2F; 多线程 parallel: 4, &#x2F;&#x2F; 缓存 cache: true, &#125;) &#125; &#125; &#125;复制代码 hard-source-webpack-plugin 或者 cache-loader1.5 减少文件搜素范围优化loader配置由于 Loader 对文件的转换操作很耗时，所以需要让尽可能少的文件被 Loader 处理。可以通过 test/include/exclude 三个配置项来命中 Loader 要应用规则的文件。 使用合理的alias在实战项目中经常会依赖一些庞大的第三方模块，以 Vue 库为例，发布出去的 Vue 库中包含多套代码, vue.runtime.esm.js 中只包含运行时的代码。如果不用template选项可以直接用这个减少打包体积。 12345678module.exports &#x3D; &#123; resolve: &#123; alias: &#123; &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.runtime.esm.js&#39;, &#125; &#125; &#125;复制代码 优化resolve.modules配置resolve.modules 的默认值是［’node_modules’］，含义是先去当前目录的node_modules目录下去找我们想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules中找，以此类推。当安装的第三方模块都放在项目根目录的 node_modules 目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找。 123456module.exports &#x3D; &#123; resolve: &#123; modules: [path.resolve( __dirname,&#39;node modules&#39;)] &#125; &#125;复制代码 优化resolve.mainFields配置在安装的第三方模块中都会有一个package.json文件，用于描述这个模块的属性,其中可以存在多个字段描述入口文件，原因是某些模块可以同时用于多个环境中，针对不同的运行环境需要使用不同的代码。 segmentfault.com/a/119000001… 优化resolve.extensions配置在导入语句没带文件后缀时，Webpack会自动带上后缀去尝试询问文件是否存在。如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以resolve.extensions的配置也会影响到构建的性能在配置resolve.extensions时需要遵守以下几点，以做到尽可能地优化构建性能。 后缀列表尽可能小 频率出现高的文件后缀优先放前面 源码中写导入语句时，尽可能带上后缀 1234 &#123; extensions: [&#39;.js&#39;], &#125;,复制代码 2. 构建体积优化 提取公共代码、分割代码、按需加载、懒加载 tree-shaking scope-hoisting 删除无用的css 动态polyfill 代码压缩，开启Gzip压缩 体积分析 webpack-bundle-analyzer 可以分析依赖的第三方模块的大小、业务里面组件的代码大小 1234567const BoundAnalysisPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;module.exports &#x3D; &#123; plugins: [ new BoundAnalysisPlugin(), ]&#125;复制代码 2.1 提取公共代码、分割代码、按需加载、懒加载12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; 组件按需加载import &#123;Button&#125; from &#39;element-ui&#39;;&#x2F;&#x2F; 模块按需加载import &#123;cloneDeep&#125; from &#39;lodash-es&#39;;&#x2F;&#x2F; Vue 路由懒加载const Foo &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;group-foo&quot; *&#x2F; &#39;.&#x2F;Foo.vue&#39;)复制代码optimization: &#123; splitChunks: &#123; chunks: &#39;all&#39;, minSize: 30000, minRemainingSize: 0, maxSize: 0, minChunks: 1, maxAsyncRequests: 6, maxInitialRequests: 4, automaticNameDelimiter: &#39;~&#39;, automaticNameMaxLength: 30, cacheGroups: &#123; vendors: &#123; test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;复制代码 2.2 tree-shaking 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉。 注意事项： mode: production 默认开启 babel设置 modules:false, 必须使用ES6的语法 2.3 删除无用的css 使用 purgecss-webpack-plugin 配合 mini-css-extract-plugin 使用 123456789101112131415161718192021222324252627282930313233const config &#x3D; &#123; module:&#123; rules: [ &#123; test: &#39;&#x2F;.scss$&#x2F;&#39;, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;, &#123; loader: &#39;postcss-loader&#39;, options: &#123; plugins: () &#x3D;&gt; [ &#x2F;&#x2F; 自动扩展css require(&#39;autoprefixer&#39;)(), ], &#125;, &#125;, &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: getAssetPath( &#96;css&#x2F;[name]_[contenthash:8]&#39;&#125;.css&#96;, ), &#125;), new PurgecssPlugin(&#123; paths: glob.sync(&#96;$&#123;PATHS.src&#125;&#x2F;**&#x2F;*&#96;, &#123; nodir: true &#125;), &#125;), ]&#125;复制代码 2.4 动态polyfill 方案 优点 缺点 babel-polyfill 大而全 体积太大 @babel/plugin-transform-runtime 只polyfill用到的方法和类，体积较小 不能polyfill原型上的方法 polyfill-service 只返回客户需要的polyfill 国内奇葩浏览器 2.5 Scope-Hoisting ModuleConcatenationPlugin 现在webpack4在mode 不等于none都支持 2.6 图片压缩，代码压缩，还可以开启Gzip压缩 使用 image-webpack-loader进行图片压缩 3. 加载优化3.1 预加载 使用 @vue/preload-webpack-plugin 实现代码预加载 1234567891011121314const config &#x3D; &#123; plugins: [ new PreloadPlugin(&#123; rel: &#39;preload&#39;, include: &#39;initial&#39;, fileBlacklist: [&#x2F;\\.map$&#x2F;, &#x2F;hot-update\\.js$&#x2F;], &#125;), new PreloadPlugin(&#123; rel: &#39;prefetch&#39;, include: &#39;asyncChunks&#39;, &#125;), ]&#125;复制代码 3.2 使用文件指纹，浏览器缓存 Hash：和整个项⽬的构建相关，只要项⽬文件有修改，整个项⽬构建的 hash 值就会更改 Chunkhash：和 webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值 Contenthash：根据文件内容来定义 hash ，文件内容不不变，则 contenthash 不不变 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; js&#123; output: &#123; filename: &#39;[name]_[chunkhash:8].js&#39; &#125; &#125;&#x2F;&#x2F; css&#x2F;&#x2F; MiniCssExtractPlugin&#123; plugins:[ new MiniCssExtractPlugin(&#123; filename: &#39;[name]_[contenthash:8].css&#39; &#125;) ]&#125;&#x2F;&#x2F; 图片 &#x2F;&#x2F; file-loader 使用hash（这里的hash是根据内容生成的，默认是md5）&#123; module:&#123; rules:[ &#123; test: &#x2F;\\.(png|svg|jpg|gif)$&#x2F;, use: [&#123; loader: &#39;file-loader’, options: &#123; name: &#39;img&#x2F;[name][hash:8].[ext] &#39; &#125; &#125;] &#125; ] &#125;&#125;","tags":[]},{"title":"样式和兼容问题","date":"2020-01-05T05:24:54.407Z","path":"2020/01/05/样式和兼容问题/","text":"样式问题1、父元素设置了border-radius，子元素应用了transform，并且父元素设置了overflow:hidden，但是却失效？123456&#x2F;&#x2F; 给父元素设置 &#123; position:relative; z-index:1;&#125;复制代码 2、设置input 文本框的 placeholder 的颜色1234input::-webkit-input-placeholder&#123; color:rgba(144,147,153,1);&#125;复制代码 3、如何设置body背景色，height:100%,不生效？12345678910同时设置html，body的高度html,body&#123; height:100%；&#125; 或body&#123; height: 100vh; &#x2F;&#x2F; 代表占屏幕100%&#125;复制代码 4、一像素边框的问题1234567891011121314151617181920.row &#123; position: relative; &amp;:after&#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; width: 200%; border-bottom:1px solid #e6e6e6; color: red; height: 200%; -webkit-transform-origin: left top; transform-origin: left top; -webkit-transform: scale(0.5); transform: scale(0.5); pointer-events: none; &#x2F;* 防止点击触发 *&#x2F; box-sizing: border-box; &#125;&#125;复制代码 5、css属性touch-action:none;12该属性会导致安卓页面无法滚动，慎用!复制代码 6、去除ios 手机端input输入框的内阴影1234input&#123; -webkit-appearance: none; &#125;复制代码 7、安卓手机端div里面在包一层div，文字展示不居中的问题。12最好给div设置padding ，不固定高度和不设置line-height；复制代码 8、iOS端input输入框光标错位是由于fixed定位引起的，改成absolute就解决了。 1234.box&#123; position: absolute; &#125;复制代码 9、div实现背景色和背景图片同时存在123456&#123; background-color: #fff; background-image:url(&#39;..&#x2F;..&#x2F;assets&#x2F;img&#x2F;model-bg.png&#39;); background-repeat: no-repeat;&#125;复制代码 10、css 制作椭圆 border-radius可以单独设置水平和垂直的半径，只需要用一个斜杠（/）分隔这二个值就行。 此外我们还要知道border-radius不仅可以接受长度值还可以接受百分比值。 1234567&#123; width: 150px; height: 100px; border-radius: 50%&#x2F;50%; &#x2F;&#x2F;简写属性：border-radius:50% background: brown;&#125;复制代码 11、图片居中显示12object-fit: cover;复制代码 兼容问题1、iconfont 字体在钉钉应用里面加载不出来（或者是乱码）的问题引入iconfont字体的时候，需要按照顺序把字体依次引入。正确的顺序如下：123456789@font-face &#123; font-family: &quot;djicon&quot;; src: url(&#39;.&#x2F;iconfont.eot&#39;); &#x2F;* IE9*&#x2F; src: url(&#39;.&#x2F;iconfont.svg#iconfont&#39;) format(&#39;svg&#39;), &#x2F;* iOS 4.1- *&#x2F; url(&#39;.&#x2F;iconfont.woff&#39;) format(&#39;woff&#39;), &#x2F;* chrome、firefox *&#x2F; url(&#39;.&#x2F;iconfont.ttf&#39;) format(&#39;truetype&#39;); &#x2F;* chrome、firefox、opera、Safari, Android, iOS 4.2+*&#x2F;&#125;&#x2F;&#x2F; 参考文档：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Megasu&#x2F;p&#x2F;4305116.html复制代码 2、PC端ueditor 编辑的文案及图片拉伸问题，背景是 后端返回是html片段node - cheerio模块，操作dom字符串比较方便，实际案例：解决了 PC端图片在移动端展示的问题参考文档：www.jianshu.com/p/e6d73d8fa…www.npmjs.com/package/che… 1234567891011121314151617181920212223242526width: number &#x3D; 784 代表pc端宽度 regHtml(str: string)&#123; &#x2F;&#x2F; 参数是html片段 let _this &#x3D; this; const $ &#x3D; cheerio.load(str); $(&#39;img&#39;).each(function(index,element)&#123; let attr &#x3D; element.attribs &#x2F;&#x2F;元素的属性 &#x2F;&#x2F; 屏幕宽度 let docEl &#x3D; document.documentElement let clientWidth &#x3D; docEl.clientWidth if(attr.width)&#123; &#x2F;&#x2F;如果设置了宽 &#x2F;&#x2F; 图片宽度&#x2F;屏幕宽度的比例 let rate &#x3D; attr.width &#x2F;_this.width &#x2F;&#x2F;图片的宽高比例 let wh &#x3D; attr.width&#x2F;attr.height $(element).attr(&#39;height&#39;, _this.rate*clientWidth&#x2F;wh) $(element).attr(&#39;width&#39;, _this.rate*clientWidth) $(element).attr(&#39;style&#39;, &#39;&#39;) $(element).attr(&#39;class&#39;, &#39;img-skew&#39;) &#125; &#125;) return $.html() &#125;复制代码 3、IOS 点击input不聚焦问题。ios系统中点击Input输入框，没有反应，无法聚集光标，调不起键盘。 解决方案：强制性给加上点击事件，点击后给input框聚集光标。 1234cilckTextarea()&#123; document.getElementsByClassName(&#39;cont-inp&#39;)[0].focus();&#125;,复制代码 4、上传图片，iPhone7 iPhone7p在上传图片的时候，传不过去图片的name解决方案：手动添加图片name 123let data &#x3D; new FormData();data.append(&quot;fileName&quot;, file[0],file[0].name); 复制代码 5、ios微信打开网页键盘弹起后页面上滑，导致弹框里的按钮响应区域错位解决方案：手动把滚动条滚到底部写一个自定义指令。 12345678910import Vue from &#39;vue&#39;;Vue.directive(&#39;blur&#39;, &#123; &#39;bind&#39;(el) &#123; el.addEventListener(&quot;click&quot;, function()&#123; window.scrollTo(0,0); &#125;) &#125;&#125;); &#x2F;&#x2F;在点击页面提交按钮的时候，把滚动条滚到底部就OK了复制代码 6、微信浏览器调整字体后，页面错位。解决方案：阻止页面字体自动调整大小 1234567891011121314151617181920212223242526&#x2F;&#x2F; 安卓：(function() &#123; if (typeof WeixinJSBridge &#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke &#x3D;&#x3D; &quot;function&quot;) &#123; handleFontSize(); &#125; else &#123; if (document.addEventListener) &#123; document.addEventListener(&quot;WeixinJSBridgeReady&quot;, handleFontSize, false); &#125; else if (document.attachEvent) &#123; &#x2F;&#x2F;IE浏览器，非W3C规范 document.attachEvent(&quot;onWeixinJSBridgeReady&quot;, handleFontSize); &#125; &#125; function handleFontSize() &#123; &#x2F;&#x2F; 设置网页字体为默认大小 WeixinJSBridge.invoke(&#39;setFontSizeCallback&#39;, &#123; &#39;fontSize&#39; : 0 &#125;); &#x2F;&#x2F; 重写设置网页字体大小的事件 WeixinJSBridge.on(&#39;menu:setfont&#39;, function() &#123; WeixinJSBridge.invoke(&#39;setFontSizeCallback&#39;, &#123; &#39;fontSize&#39; : 0 &#125;); &#125;); &#125;&#125;)();&#x2F;&#x2F;iOS：&#x2F;&#x2F; ios使用-webkit-text-size-adjust禁止调整字体大小body&#123;-webkit-text-size-adjust: 100%!important;&#125;复制代码 7、关于移动端样式兼容的问题 设置meta标签viewport属性，使其无视设备的真实分辨率，直接通过dpi，在物理尺寸和浏览器之间重设分辨率，从而达到能有统一的分辨率的效果。并且禁止掉用户缩放 12&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0, user-scalable&#x3D;no&quot; &#x2F;&gt;复制代码 使用rem进行屏幕适配，设置好root元素的font-size大小，然后在开发的时候，所有与像素有关的布局统一换成rem单位。 8、iOS下取消input在输入的时候英文首字母的默认大写12&lt;input type&#x3D;&quot;text&quot; autocapitalize&#x3D;&quot;none&quot;&gt;复制代码 9、禁止 iOS 识别长串数字为电话12&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;复制代码 10、禁止ios和android用户选中文字12-webkit-user-select: none;复制代码 11、一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发只需要对不触发click事件的元素添加一行css代码即可： 12cursor: pointer;复制代码 调试工具1、Weinre远程调试工具简单的步骤： 1234567- 本地全局安装weinre , 命令行：npm install -g weinre- 在本地启动一个检测器：weinre --boundHost 1.2.3.4 （IP为本地IP地址）- 在浏览器访问此地址：http:&#x2F;&#x2F;1.2.3.4:8080- 把下面这一串东西，放在你需要调试的页面里：&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;1.2.3.4:8080&#x2F;target&#x2F;target-script-min.js#anonymous&quot;&gt;&lt;&#x2F;script&gt;- 点击链接打开：http:&#x2F;&#x2F;1.2.3.4:8080&#x2F;client&#x2F;#anonymous复制代码 2、vconsole 日志打印123import VConsole from &#39;vconsole&#39;var vConsole &#x3D; new VConsole();复制代码 3、fiddler抓包也需要支持https解决方案：fiddler需要安装信任证书，手机也需要安装信任证书，在浏览器里面打开 12http:&#x2F;&#x2F;1.2.3.4:8888 &#x2F;&#x2F; 本地IP地址+端口号复制代码 4、charles 手机端抓包，需要安装证书123手机浏览器输入：chls.pro&#x2F;ssl ，去下载证书。手机-设置-安全与隐私-更多安全下载-从sd卡安装证书 - 找到之前在浏览器下载的证书复制代码 vue相关问题1、vue 如何获取拉回数据后图片的高度？12345678910111213&lt;img :src&#x3D;&quot;userInfo.profilePicture&quot; alt class&#x3D;&quot;img-picture&quot; v-if&#x3D;&quot;userInfo.profilePicture&quot; ref&#x3D;&quot;myImg&quot; @load&#x3D;&quot;imageFn&quot;&gt; imageFn() &#123; console.log(this.$refs.myImg.offsetHeight); console.log(this.$refs.myImg.offsetWidth); &#125;,复制代码 2、vue中同一个dom节点，v-if与v-for不推荐同时使用，官方解答： 不推荐同时使用 v-if 和 v-for。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级 3、vue v-for 中更改item 属性值后，v-show不生效的问题123添加this.$forceUpdate();进行强制渲染，效果实现。因为数据层次太多，render函数没有自动更新，需手动强制刷新。复制代码 4、这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消12345678beforeRouteLeave(to, from, next) &#123; if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;votes&#x2F;subject&#39;) &#123; next(&#39;&#x2F;task-list&#39;); &#125; else &#123; next(); &#125;&#125;复制代码 5、element UI 自定义传参的解决方法这里的handleSelect默认绑定的参数是选中的那条数据。如果一个页面有好几个相同的组件，要想知道选的是哪个？ 1234567&lt;el-autocomplete v-model&#x3D;&quot;state4&quot; :fetch-suggestions&#x3D;&quot;querySearchAsync&quot; placeholder&#x3D;&quot;请输入内容&quot; @select&#x3D;&quot;handleSelect&quot;&gt;&lt;&#x2F;el-autocomplete&gt;复制代码 解决方案： 12345678&lt;el-autocomplete v-model&#x3D;&quot;state4&quot; :fetch-suggestions&#x3D;&quot;querySearchAsync&quot; placeholder&#x3D;&quot;请输入内容&quot; @select&#x3D;&quot;((item)&#x3D;&gt;&#123;handleSelect(item, index)&#125;)&quot; &#x2F;&#x2F; 写个闭包就可以了，index表示第几个组件&gt;&lt;&#x2F;el-autocomplete&gt;复制代码 6、element-UI 框架 el-input 触发不了 @key.enter事件12345&lt;el-input v-model&#x3D;&quot;form.loginName&quot; placeholder&#x3D;&quot;账号&quot; @keyup.enter&#x3D;&quot;doLogin&quot;&gt;&lt;&#x2F;el-input&gt;复制代码 解决方案：使用@key.center.native 1234&lt;el-input v-model&#x3D;&quot;form.loginName&quot;placeholder&#x3D;&quot;账号&quot; @keyup.enter.native&#x3D;&quot;doLogin&quot;&gt;&lt;&#x2F;el-input&gt; 转载自掘金快狗打车前端团队 https://juejin.im/post/5dfb3e73f265da33b12ea9d3#heading-26","tags":[]},{"title":"构建大型Vue-js项目的10条建议","date":"2019-12-30T02:09:20.605Z","path":"2019/12/30/构建大型Vue-js项目的10条建议/","text":"构建大型 Vue.js 项目的10条建议下面是我在开发大型 Vue 项目时的最佳实践。这些技巧将帮助你开发更高效、更易于维护和共享的代码。 今年做自由职业的时候，我有机会开发了一些大型 Vue 应用程序。我所说的这些项目，Vuex store 超过十个，包含大量的组件（有时候几百个）和视图页面。对我来说这是个很有益的经验，因为我发现了很多有意思的模式，可以让代码拥有更好的伸缩性。我还必须修正一些导致著名的意大利面条式代码困境的错误实践。 因此，今天我将与你分享10个最佳实践，如果你正在处理大型代码库，我建议你参考这些方法。 1. 使用 slot, 让组件更强大，也更容易理解最近我写了篇关于 Vue.js slot 的文章，它强调了 slot 如何使组件更易于重用和维护，以及为什么应该使用它们。 🧐 但是这与 Vue.js 大型项目有什么关系呢？一张图片通常胜过千言万语，所以我要给你描绘一幅关于我第一次后悔没有使用它们的画面。 有一天，我要创建一个 popup。乍一看并没有什么复杂的东西，只是包含了一个标题，一个描述和一些按钮。所以我所做的就是把一切配置一股脑当做 props 传进去。最终我定义了三个 prop，用于自定义组件，当用户单击按钮时将发送一个事件。So easy ! 但是，随着项目的发展，团队要求我们在其中展示更多其他的新内容：表单字段、不同的按钮(取决于它显示在哪个页面上)、卡片、页脚，以及列表。我以为，如果继续使用 prop 来迭代这个组件也没啥问题。但是我滴个神哪，我是大错特错！组件很快变得非常复杂，难以理解，因为它包含了无数的子组件，用了太多的 prop，并发送了一堆的事件。我开始体验到了可怕的情况，当你做出一点改动，其他页面的某个地方就会崩溃！我仿佛造了一个 Frankenstein 怪人，而不是一个可维护的组件!🤖 然而，如果我从一开始就依赖 slot，情况可能会好多了。最后我重构了所有东西，得到了这个小组件：更容易维护，理解起来更快，更好扩展！ 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class&#x3D;&quot;c-base-popup&quot;&gt; &lt;div v-if&#x3D;&quot;$slot.header&quot; class&#x3D;&quot;c-base-popup__header&quot;&gt; &lt;slot name&#x3D;&quot;header&quot;&gt; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;$slot.subheader&quot; class&#x3D;&quot;c-base-popup__subheader&quot;&gt; &lt;slot name&#x3D;&quot;subheader&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;c-base-popup__body&quot;&gt; &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h1&gt; &lt;p v-if&#x3D;&quot;description&quot;&gt;&#123;&#123; description &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;$slot.actions&quot; class&#x3D;&quot;c-base-popup__actions&quot;&gt; &lt;slot name&#x3D;&quot;actions&quot;&gt; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;$slot.footer&quot; class&#x3D;&quot;c-base-popup__footer&quot;&gt; &lt;slot name&#x3D;&quot;footer&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: &#123; description: &#123; type: String, default: null &#125;, title: &#123; type: String, required: true &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 我的观点是，从经验来看，那些知道何时使用 slot 的开发人员所构建的项目确实会对其未来的可维护性产生很大的影响。由于发送的事件更少，代码更容易理解，而且提供了更大的灵活性，可以在其中显示任何组件。 ️ 敲黑板：根据经验，当你开始在父组件中复制子组件的 prop 时，你就应该考虑使用 slot 了。 2. 合理组织 Vuex Store通常，Vue.js 新手开始了解Vuex，因为他们刚好碰到了这两个问题： 组件树结构中相隔太远的组件之间访问数据 组件销毁后需要持久化数据 这个时候他们就会创建第一个 Vuex store，学习模块并开始在应用程序中组织它们。 问题在于，创建模块时没有单一的模式可以遵循。然而，我强烈建议你仔细考虑如何组织它们。据我所见，大多数开发人员更喜欢根据功能来组织它们。例如: Auth. Blog. Inbox. Settings. 就我来说，我发现根据从 API 获取的数据模型来组织它们更容易理解。例如: Users Teams Messages Widgets Articles 如何选择取决于你自己。唯一需要记住的是，从长远来看，一个组织良好的 Vuex store 会造就一个更高效的团队。它还将使新人在加入团队时更容易将他们的想法围绕在你的代码基础上。 3. 使用 action 发起 API 调用和提交数据我的大部分 API 调用（如果不是全部）是在Vuex action 里面完成的。你可能会问：为什么要这么做？ 🤨 🤷‍♀️ 简单来说，它们中的大多数获取的数据需要提交到 store里去。另外，它们还提供了一层封装和可重用性，我很喜欢用。还有一些原因如下： 如果我需要在两个地方（假设是博客页面和首页）获取文章的第一页，我只需要用正确的参数调用合适的 dispatcher 就行了。除了 dispatcher 调用，无需重复代码就可以完成数据的获取，commit 到 store 和返回。 如果我需要写一些避免重复获取第一页的逻辑，我就可以在一个地方完成。这样做除了会减轻服务器负载，还会增强我对代码的信心。 我可以跟踪这些操作中的大多数 Mixpanel（一个网站用户行为分析工具） 事件，这使得分析代码非常容易维护。我确实有一些应用程序，其中所有的 Mixpanel 调用都是只在 action 中完成的。我不需要了解哪些数据被跟踪，哪些没有，以及什么时候发送这些信息。以这种工作方式的乐趣简直无法言说。 4. 用 mapState，mapGetters，mapMutations 和 mapActions 简化代码通常不需要创建多个计算属性或方法，只需在组件内部访问 state/getters 或者调用 actions/mutations 。使用mapState，mapGetters，mapMutations 和 mapActions 可以帮助你简化代码，把来自 store 模块的数据分组到一起，让代码更容易理解。 123456789101112131415161718192021222324&#x2F;&#x2F; NPMimport &#123; mapState, mapGetters, mapActions, mapMutations &#125; from &quot;vuex&quot;;export default &#123; computed: &#123; &#x2F;&#x2F; Accessing root properties ...mapState(&quot;my_module&quot;, [&quot;property&quot;]), &#x2F;&#x2F; Accessing getters ...mapGetters(&quot;my_module&quot;, [&quot;property&quot;]), &#x2F;&#x2F; Accessing non-root properties ...mapState(&quot;my_module&quot;, &#123; property: state &#x3D;&gt; state.object.nested.property &#125;) &#125;, methods: &#123; &#x2F;&#x2F; Accessing actions ...mapActions(&quot;my_module&quot;, [&quot;myAction&quot;]), &#x2F;&#x2F; Accessing mutations ...mapMutations(&quot;my_module&quot;, [&quot;myMutation&quot;]) &#125;&#125;;复制代码 有关以上工具方法的所有信息都在 Vuex 官方文档。🤩 5. 使用 API 工厂我通常喜欢写一个this.$api 助手，以便在任何地方调用，获取后台 API 资源。在我的项目根目录有一个api 文件夹，包含了所有相关的类。如下所示（仅部分）： 123456api├── auth.js├── notifications.js└── teams.js复制代码 每个文件都将其类别下的所有 API 资源分组。下面是我在 Nuxt 应用中使用插件初始化这个模式的方法（在标准的 Vue 应用中的过程也类似）。 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; PROJECT: APIimport Auth from &quot;@&#x2F;api&#x2F;auth&quot;;import Teams from &quot;@&#x2F;api&#x2F;teams&quot;;import Notifications from &quot;@&#x2F;api&#x2F;notifications&quot;;export default (context, inject) &#x3D;&gt; &#123; if (process.client) &#123; const token &#x3D; localStorage.getItem(&quot;token&quot;); &#x2F;&#x2F; Set token when defined if (token) &#123; context.$axios.setToken(token, &quot;Bearer&quot;); &#125; &#125; &#x2F;&#x2F; Initialize API repositories const repositories &#x3D; &#123; auth: Auth(context.$axios), teams: Teams(context.$axios), notifications: Notifications(context.$axios) &#125;; inject(&quot;api&quot;, repositories);&#125;;复制代码export default $axios &#x3D;&gt; (&#123; forgotPassword(email) &#123; return $axios.$post(&quot;&#x2F;auth&#x2F;password&#x2F;forgot&quot;, &#123; email &#125;); &#125;, login(email, password) &#123; return $axios.$post(&quot;&#x2F;auth&#x2F;login&quot;, &#123; email, password &#125;); &#125;, logout() &#123; return $axios.$get(&quot;&#x2F;auth&#x2F;logout&quot;); &#125;, register(payload) &#123; return $axios.$post(&quot;&#x2F;auth&#x2F;register&quot;, payload); &#125;&#125;);复制代码 现在，我可以简单地在我的组件或 Vuex action 里像这样调用它们： 12345678910111213export default &#123; methods: &#123; onSubmit() &#123; try &#123; this.$api.auth.login(this.email, this.password); &#125; catch (error) &#123; console.error(error); &#125; &#125; &#125;&#125;;复制代码 6. 使用 $config 访问环境变量（在模板里特别有用）你的项目可能在一些文件中定义了一些全局配置变量： 12345config├── development.json└── production.json复制代码 我喜欢通过 this.$config 助手快速访问它们，特别是在模板里。像往常一样，扩展 Vue 对象非常容易： 1234567891011121314&#x2F;&#x2F; NPMimport Vue from &quot;vue&quot;;&#x2F;&#x2F; PROJECT: COMMONSimport development from &quot;@&#x2F;config&#x2F;development.json&quot;;import production from &quot;@&#x2F;config&#x2F;production.json&quot;;if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot;) &#123; Vue.prototype.$config &#x3D; Object.freeze(production);&#125; else &#123; Vue.prototype.$config &#x3D; Object.freeze(development);&#125;复制代码 7. 按照某个约定来给代码提交命名随着项目的增长，你可能需要定期浏览组件的历史记录。如果你的团队没有遵循相同的约定来命名他们的提交，那么理解每个提交将会变得更加困难。 我一直推荐使用 Angular 提交信息指南。我在每个项目中都遵循它，在很多情况下，其他团队成员很快就会发现遵循它带来的好处。 遵循这些指导原则可以得到更具可读性的信息，这使得在查看项目历史记录时更容易跟踪提交。简而言之，它是这样工作的： 1234567git commit -am &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;# 举例git commit -am &quot;docs(changelog): update changelog to beta.5&quot;git commit -am &quot;fix(release): need to depend on latest rxjs and zone.js&quot;复制代码 看下他们的 README 文件 了解更多了解更多关于它和相关约定。 8. 项目上线后固定 package 版本我知道，所有 package 都应该遵循语义化版本规则。但现实情况是，有些根本没有遵守。 为了避免因为某个依赖项破坏了整个项目而不得不在半夜醒来，锁定所有 package 版本可以让你的早晨工作压力更小。 它的意思很简单：避免使用带 ^ 前缀的版本号： 1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;my project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;axios&quot;: &quot;0.19.0&quot;, &quot;imagemin-mozjpeg&quot;: &quot;8.0.0&quot;, &quot;imagemin-pngquant&quot;: &quot;8.0.0&quot;, &quot;imagemin-svgo&quot;: &quot;7.0.0&quot;, &quot;nuxt&quot;: &quot;2.8.1&quot;, &#125;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;9.6.1&quot;, &quot;babel-eslint&quot;: &quot;10.0.2&quot;, &quot;eslint&quot;: &quot;6.1.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;4.0.1&quot;, &quot;eslint-loader&quot;: &quot;2.2.1&quot;, &quot;eslint-plugin-vue&quot;: &quot;5.2.3&quot; &#125;&#125;复制代码 9. 在显示大量数据时使用 Vue Virtual Scroller当你需要在某个页面中显示大量的行，或者需要循环大量的数据时，你可能已经注意到页面可能会很快变得非常慢。要解决这个问题，你可以使用vue-virtual-scoller。 123npm install vue-virtual-scroller复制代码 它将只渲染列表中可见的项，并重用组件和 dom 元素，效率高，性能好。它真的很容易使用，如丝般顺滑！✨ 123456789101112131415&lt;template&gt; &lt;RecycleScroller class&#x3D;&quot;scroller&quot; :items&#x3D;&quot;list&quot; :item-size&#x3D;&quot;32&quot; key-field&#x3D;&quot;id&quot; v-slot&#x3D;&quot;&#123; item &#125;&quot; &gt; &lt;div class&#x3D;&quot;user&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;RecycleScroller&gt;&lt;&#x2F;template&gt;复制代码 10. 跟踪第三方包的大小当很多人在同一个项目中工作时，如果没人关注安装包的数量，那么很快就会越来越多。为了避免应用程序变慢(特别是在移动网络变慢的情况下)，我在 VS Code 中使用了 import cost 插件。这样，我就可以从我的编辑器中看到导入的模块库有多大，并且可以在它变得太大时检查出问题。 例如，在最近的一个项目中，整个 lodash 库被导入(大约有24kB的gzipped)。结果只使用了 cloneDeep 方法。通过 import cost 插件定位到这个问题，我们是这样解决的： 1234npm remove lodashnpm install lodash.clonedeep复制代码 cloneDeep 函数可以在需要的地方引入： 123import cloneDeep from &quot;lodash.clonedeep&quot;;复制代码 ️ 要进一步优化，你可以使用 Webpack Bundle Analyzer ，用交互式的可缩放地图可视化文件大小。","tags":[]},{"title":"前端性能优化(一)","date":"2019-12-29T01:46:18.206Z","path":"2019/12/29/前端性能优化(一)/","text":"前端性能优化（一）在讨论具体如何优化之前，先思考一个经典问题，从输入 URL 到页面加载完成到底发生了什么？ URL 经过 DNS 解析为 IP 地址，然后与 IP 地址进行 TCP 连接，随后发出 HTTP 请求，服务器处理完请求之后将内容通过 HTTP 发送给客户端，拿到数据后浏览器就开始渲染流程。简单的说分为以下几个步骤：DNS 解析，TCP 连接，HTTP 请求，HTTP响应，浏览器解析并渲染。 这个问题解决之后，就可以从各个层面分析如何做性能优化了。 DNS 预解析DNS 预解析是指浏览器视图在用户访问链接之前解析域名。那接下来用户如果确实访问了该域名，那 DNS 的解析时间将不会有延迟。浏览器对网站第一次的域名 DNS 查找流程为：浏览器缓存 =&gt; 系统缓存 =&gt; 路由器缓存 =&gt; ISP DNS 缓存 =&gt; DNS 服务器。所以我们不需要对和当前页面中同一个域的域名进行预获取（浏览器会缓存解析结果）。 使用起来也很简单： 1234&#x2F;&#x2F; 如果需要禁用隐式的 DNS prefetch 设置 content &#x3D; &quot;off&quot;&lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot;&gt;&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;ha.aa.bb&quot;&gt;复制代码 HTTP2 &amp;&amp; HTTP1先来一个例子大家直观感受下两者的差异，可以看到 HTTP/2 性能有大幅提高。这里就必须提到其引入的多路复用技术，在这个技术的支持下，同一域名下的所有请求都在一个通道内完成。这也是引入了帧和流的概念，帧是数据最小传输单位，且标记了属于哪个流，流就是多个数据帧组成的数据流。多路复用就是一个连接下存在多个流。而 HTTP/1 中每个请求都必须创建一个 TCP 连接，浏览器还限制了同一个域名下的请求数量，当请求资源较多的时候会出现队头阻塞。 且 HTTP/2 采用二进制传输代替了 HTTP/1 中的文本传输，解析更加高效。 浏览器缓存策略缓存是性能优化中性价比很高的一种优化方式，显著的减少了网络传输带来的损耗。 浏览器的缓存机制有四种，按优先级排列如下： Service Worker Memory Cache Disk Cache Push Cache 当以上都没有命中资源的时候才去做网络请求。 Service WorkerService Worker 是运行在浏览器背后的独立线程，且脱离浏览器窗口，因此无法直接访问 DOM。也正是独立的特点，我们往往可以通过它实现离线缓存，消息推送和网络代理等功能。但由于涉及到网络代理的，使用 Service Worker 时，传输协议必须为 HTTPS。 使用步骤分为三步：注册 Service Worker；监听 install 事件，并缓存需要的文件；在下次请求的时候通过拦截请求的方式查询是否存在缓存，存在的话直接读取缓存文件，否则请求资源。 有一点需要注意的是，当我们没有在 Service Worker 命中缓存，需要调用 fetch 函数获取数据时，浏览器会依次根据缓存优先级继续查找，但此时找到的数据依旧会显示是从 Service Worker 中获取的。 Memory CacheMemory Cache 是指内存中的缓存，是速度非常快的一种缓存。但是虽然读取效率高，其生存时间较短，一旦 Tab 页关闭，内存中的缓存就被释放了。但是具体哪部分内容会被缓存并不确定，需要根据系统内存的具体情况判断。 Disk CacheDisk Cache 是指存在硬盘中的缓存，读取速度较慢，但是时效性较高。即使在跨站点的情况下，相同地址的资源一旦被缓存下来就不会再次去请求数据。 Push CacheHTTP/2 中的内容，不太了解~~有了解的同学可以一起交流下呀 缓存策略前面提到了各种类型的缓存，但是究竟要不要缓存，怎么判断缓存过期时间，这些问题都要从缓存策略中找到答案。 浏览器的缓存策略分为两种：强缓存和协商缓存。 强缓存强缓存的实现依赖 Expires 和 Cache-Control 两个字段来控制。强缓存表示缓存期间不需要再次请求，返回状态码 200。 强缓存的早期实现是靠 Expires 字段，这个字段是一个时间戳，表示在这个事件前的缓存都是有效的。可以看到这个字段十分依赖本地时间，如果修改客户端时间可能就会出问题。 HTTP/1.1 出现的 Cache-Control 可以完全替代 Expires 并提供更丰富的功能。它提供了很多指令： 指令 作用 public 表示响应可以被客户端和代理服务器缓存 private 表示响应只能被客户端缓存 max-age=30 缓存 30 s 后过期 s-maxage=30 覆盖 max-age ，但只在代理服务器中生效 no-store 不缓存任何响应 no-cache 资源被缓存但是立即失效，下次会发起请求验证资源是否过期 max-stale=30 30s 内及时缓存过期也使用该缓存 min-fresh=30 希望在 30s 内获取最新的响应 协商缓存如果缓存过期了或是设置了 no-cache，则进入协商缓存阶段。协商缓存的实现依赖于两个字段：：Etag 以及 Last-modified。当浏览器发起验证请求资源时，如果资源没有改动，就返回 304 状态码，并更新缓存有效期。 当浏览器发起请求时，会带上 If-Modified-Since 字段，它的值是上次请求资源时 Last-modified 提供的时间戳。服务器再判断在这个时间戳之后是否有改动。但是这个机制还是存在弊端的，因为时间戳是以秒为单位计算的，如果再 1s 内的改动是无法被感知到的。 Etag 就是为了解决上述问题出现的，浏览器会将上次请求资源返回结果携带的 Etag 作为 If-None-Match 的值发送给服务器，有变动的话就返回新的资源。Etag 的缺陷在于服务器需要有额外的开销，可能会影响性能。 那当没有设置缓存策略时，浏览器会怎么办？通常会取响应头中的 DATE 减去 Last-modified 值的 10% 作为缓存时间。 实际应用策略大致了解了浏览器缓存机制之后，要怎么利用它们来提高性能呢？这才是我们真正要解决的问题。 对于频繁变动的资源，可以设置 Cache-Control: no-cache ，让浏览器每次都请求服务器验证资源是否有效。如果有效，可以有效减少响应数据大小。 对于一些打包过后的代码文件，比如 webpack ，通常我们都会对文件名做哈希处理，一般只要文件改动过了，文件名就会改动。所以对于这类文件，可以采用强缓存策略，设置较长时间的缓存时间，比如 Cache-Control: max-age=31536000。 构建工具优化减少打包时间 优化 Loader 就拿 Babel 举例，首先优化 Loader 的文件搜索范围，合理利用 test ，include，exclude ；缓存编译过的文件，下次只需要编译更改过的代码即可： 12loader: &#39;babel-loader?cacheDirectory&#x3D;true&#39;复制代码 HappyPack HappyPack 将 loader 的同步执行转换为并行执行 123456789plugins: [ new HappyPack(&#123; id: &#39;happybabel&#39;, loaders: [&#39;babel-loader?cacheDirectory&#39;], &#x2F;&#x2F; 开启 4 个线程 threads: 4 &#125;)]复制代码 DllPlugin DllPlugin 将制定的库提前打包后引入，下次打包时只有当库版本更新后才需要重新打包。 12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; 单独配置在一个文件中&#x2F;&#x2F; webpack.dll.conf.jsconst path &#x3D; require(&#39;path&#39;)const webpack &#x3D; require(&#39;webpack&#39;)module.exports &#x3D; &#123; entry: &#123; &#x2F;&#x2F; 想统一打包的类库 vendor: [&#39;react&#39;] &#125;, output: &#123; path: path.join(__dirname, &#39;dist&#39;), filename: &#39;[name].dll.js&#39;, library: &#39;[name]-[hash]&#39; &#125;, plugins: [ new webpack.DllPlugin(&#123; &#x2F;&#x2F; name 必须和 output.library 一致 name: &#39;[name]-[hash]&#39;, &#x2F;&#x2F; 该属性需要与 DllReferencePlugin 中一致 context: __dirname, path: path.join(__dirname, &#39;dist&#39;, &#39;[name]-manifest.json&#39;) &#125;) ]&#125;&#x2F;&#x2F; 先执行上面的配置文件生成依赖文件，再使用 DllReferencePlugin 将依赖文件引入项目中&#x2F;&#x2F; webpack.conf.jsmodule.exports &#x3D; &#123; plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, &#x2F;&#x2F; manifest 就是之前打包出来的 json 文件 manifest: require(&#39;.&#x2F;dist&#x2F;vendor-manifest.json&#39;), &#125;) ]&#125;复制代码 压缩代码体积 按需加载 在开发 SPA 项目时，比较好的一个实践是，可以使用按需加载将每个路由页面单独打包为一个文件，避免首页加载文件过大，当然对于大型类库也同样适用。 Scope Hoisting 12345&#x2F;&#x2F; a.jsexport const a &#x3D; 1&#x2F;&#x2F; index.jsexport &#123;a&#125; from &#39;.&#x2F;a.js&#39;复制代码 有以上两个文件，使用 webpack打包后会变为： 1234567891011[ &#x2F;* 0 *&#x2F; function (module, exports, require) &#123; &#x2F;&#x2F;... &#125;, &#x2F;* 1 *&#x2F; function (module, exports, require) &#123; &#x2F;&#x2F;... &#125;]复制代码 使用了 Scope Hoisting 之后，代码会尽量合并到一个函数中，变为： 1234567[ &#x2F;* 0 *&#x2F; function (module, exports, require) &#123; &#x2F;&#x2F;... &#125;]复制代码 可以看到代码量会减少很多，我们可以通过在 webpack 中配置 optimization.concatenateModules 来开启 Scope Hoisting。 Tree Shaking Tree Shaking 用于删除应用中未被引用的代码，webpack4 默认开启了这个功能。 图片资源优化web 应用中图片几乎是必不可少的资源，也是十分损耗性能的一个点。图片优化的最好切入点在于根据业务场景做好图片选型方案。 JPG JPG 的特点是有损压缩，体积小，加载快，但不支持透明。所以通常可以用于大的背景图或是轮播图等色彩丰富的图片中。不适用于一些矢量图形或是对比比较鲜明的图片。 PNG PNG 的特点是无损压缩，质量高，体积大。通常用于透明图片，小 LOGO，或是颜色简单但对比强烈的图片。 SVG SVG 的特点是体积小，不失真，兼容性好。一般页面上的图标都可以用 SVG 制作，只是渲染成本较高，对性能可能略有影响。 Base64 Base64 的特点是文本文件，可用于页面上的小图标。 WebP WebP 的特点是支持透明，支持动态图片，支持有损压缩和无损压缩。但是兼容性太差，但是对于兼容 WebP 的浏览器可以尽量多使用。 CSS 很多时候一些效果可以直接通过 CSS 实现，这个时候就大胆的放弃使用图片吧。 预加载 &amp; 预渲染 预加载 12&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&quot;&gt;复制代码 如果页面某些资源可能不会马上用到，但是希望尽早获取，可以使用预加载。它会强制浏览器请求资源，但不会阻塞 onload 事件。预加载可以降低首屏加载时间，因为可以将一些不影响首屏但很重要的文件延后加载。 预渲染 12&lt;link rel&#x3D;&quot;prerender&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&quot;&gt; 复制代码 预渲染是Chrome中的一项功能，可以改善用户可见的页面加载时间。预渲染由引用页面中的 `` 元素触发。为预渲染的URL创建一个隐藏页面，该页面将完全加载所有相关资源，以及执行 JS 文件。如果用户进入该页面，则隐藏页面将被交换到当前选项卡中并使其可见。 懒加载 &amp;&amp; 懒执行 懒加载 大多数人应该都接触过图片懒加载，实际上就是将不关键的资源延后加载。举个例子，当图片没有出现在可视区域内，我们可以先统一用一张占位图来显示，将真实的 src 存入自定义属性中，当进入到到可视区域后，再替换 src 属性。 懒执行 将某些比较耗时的且不需要在首屏中使用的逻辑延后到使用时再计算，一般用于首屏优化中。 CDNCDN 是指一组分布在各个地区的服务器。这些服务器存储数据的副本，因此服务器可以根据那些服务器距离用户最近来满足数据的请求。CDN 适合被用于存放静态资源。","tags":[]},{"title":"前端萌新眼中的Promise及使用","date":"2019-12-27T08:24:42.691Z","path":"2019/12/27/前端萌新眼中的Promise及使用/","text":"前端萌新眼中的Promise及使用 一个 Promise 就是一个代表了异步操作最终完成或者失败的对象。这是MDN上关于Promise的解释。在前端开发中，Promise经常被拿来用于处理异步和回调的问题，来规避回调地狱和更好排布异步相关的代码。本篇文章对于Promise以及相关的async/await记录一些自己的理解和体会。 一、Promise的三种状态从字面的意思理解，Promise即是承诺，既是承诺，那承诺的结果就会有成功和失败两种。而且，我们许下承诺之后不会立即得到结果，在获得成功或是失败的结果之前，我们还需要一点时间来履行这个承诺。Promise的构造其实像极了我们生活中的承诺。 上面这张图就是Promise的结构图。就像我们生活中的承诺一样，Promise也存在三种状态,一种是履行承诺的pending状态，一种是承诺失败时的Rejected状态，再就是承诺成功时Fullfilled状态。 接下来，我们以爱情的名义来承诺一下： 12345678910111213141516171819let love &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F;开始谈恋爱，不过恋爱的结果要以后才知道 let happy &#x3D; Math.random() &gt;&#x3D; 0.3 ? true : false if ( happy ) &#123; resolve(&#39;marry&#39;) &#x2F;&#x2F;恋爱成功，决定结婚 &#125; else &#123; reject(&#39;break&#39;) &#x2F;&#x2F;恋爱失败，决定分手 &#125; &#125;, 500)&#125;)love.then(result &#x3D;&gt; &#123; console.log(result) &#x2F;&#x2F;处理恋爱成功的回调，result是上面resolve传过来的&#39;marry&#39;&#125;).catch(result &#x3D;&gt; &#123; console.log(result) &#x2F;&#x2F;处理恋爱失败的回调，result是上面reject传过来的&#39;break&#39;&#125;)复制代码 上面的代码就是一个简单却完整的Promise的例子。需要特别注意的是，Promise在经过pending状态达到成功或失败状态时就会凝固，即到达成功状态后再也不会失败，失败以后也不会回到成功状态。 所以下面的Promise一定是失败状态的，即便reject后面跟了resolve也没用。正所谓：若爱，请深爱，若弃，请彻底，不要暧昧，伤人伤己。柏拉图这话，说的就是Promise的状态凝固。 1234567891011let love &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; reject(&#39;break&#39;) resolve(&#39;marry&#39;)&#125;)love.then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 二、Promise的then与catch的几种写法第一种，最常见的就是上面的写法, 使用then来捕捉resolve状态，使用catch来捕捉reject状态1234567love.then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 第二种，不写catch, 把用来捕捉reject状态的函数也写到then里，但是效果和上面一样123456love.then(result &#x3D;&gt; &#123; console.log(result)&#125;, result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 第三种，分开写，也是可以的12345678love.then(result &#x3D;&gt; &#123; &#x2F;&#x2F;只捕捉和处理成功状态 console.log(result)&#125;)love.catch(result &#x3D;&gt; &#123; &#x2F;&#x2F;只捕捉和处理失败状态 console.log(result) &#125;)复制代码 三、快速构建一个成功或是失败状态的PromisePromise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise.resolve(), 用于构建成功状态的Promise;另一个是Promise.reject()，用于构建失败状态的Promise。 123456789101112let p1 &#x3D; Promise.resolve(&#39;success&#39;)console.log(p1) &#x2F;&#x2F; 打出来的是 Promise &#123;&#39;success&#39;&#125;p1.then(result &#x3D;&gt; &#123; console.log(result) &#x2F;&#x2F;打出来上面resolve传过来的字符串&#39;success&#39;&#125;)let p2 &#x3D; Promise.reject(&#39;failed&#39;) &#x2F;&#x2F;上面是一个成功状态Promise，这是一失败状态的Promisep2.catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 四、使用Promise.all()来处理一类前端场景在前端的开发实践中，我们有时会遇到需要发送多个请求并根据请求顺序返回数据的需求，比如，我们要发送a、b、c三个请求，这三个请求返回的数据分别为a1、a2、a3，而我们想要a1、a2、a3按照我们希望的顺序返回。那么，使用Promise.all()方法可以完美的解决这一问题。 假设使用代码如下： 123456789101112131415161718192021222324252627&#x2F;&#x2F;模拟异步请求的函数let request &#x3D; (name, time) &#x3D;&gt; &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; let random &#x3D; Math.random() if (random &gt;&#x3D; 0.2) &#123; resolve(&#96;$&#123;name&#125;成功了&#96;) &#125; else &#123; reject(&#96;$&#123;name&#125;失败了&#96;) &#125; &#125;, time) &#125;)&#125;&#x2F;&#x2F;构建三个Promise实例let a &#x3D; request(&#39;小明&#39;, 1000)let b &#x3D; request(&#39;小红&#39;, 500)let c &#x3D; request(&#39;小华&#39;, 1500)&#x2F;&#x2F;使用Promise.all(), 注意它接收的是一个数组作为参数 Promise.all([b,a,c]).then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 把上面的代码复制下来放到浏览器的调试控制台里多执行几次（第二次执行需要刷新）会发生什么事情呢？你可能猜到了：如果三个请求都成功的话，那么这三个请求所返回的数据就是按照发送请求的顺序排列的，即[‘小红成功了’, ‘小明成功了’, ‘小华成功了’]，而且还是以数组形式返回的；而当其中有请求失败了的话，就只会返回最先失败的结果。 当然，除了这个场景以外，Promise.all()方法还能用于其它地方。比如说，一个页面上有两个请求，只有拿到了这两个请求的数据，页面才会展示，在这之前会显示一个loading加载图。使用Promise.all()也是可以非常简洁的解决这个问题。 五、Promise的链式调用上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。 123456let p &#x3D; Promise.resolve(&#39;success&#39;)let response &#x3D; p.then(result &#x3D;&gt; &#123; console.log(result)&#125;)console.log(response) &#x2F;&#x2F;打出来的response是一个Promise对象复制代码 因为then之后返回的还是一个Promise对象，那我们就可以继续then，只不过后面then拿到的参数是上一个then里return的内容，而这个return的内容既可以是普通的字符串、数字等（最后都会被封装成Promise）也可以是自己写的一个Promise对象。 接下来我们接着上面爱的承诺继续写一个链式调用的例子： 12345678910111213141516171819202122232425262728293031let love &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; let happy &#x3D; Math.random() &gt;&#x3D; 0.3 ? true : false if ( happy ) &#123; resolve(&#39;marry&#39;) &#125; else &#123; reject(&#39;break&#39;) &#125; &#125;, 500)&#125;)let haveChild &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;孩子生了！&#39;) &#125;, 1000)&#125;)love.then(result &#x3D;&gt; &#123; console.log(result) return haveChild &#x2F;&#x2F; 这里返回一个Promise对象,它的resolve会被下一个then捕捉&#125;).then(result &#x3D;&gt; &#123; console.log(result) return &#39;最后，他们白头偕老！&#39; &#x2F;&#x2F;这里返回的字符串会传给下一个then&#125;).then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(error &#x3D;&gt; &#123; console.log(error)&#125;)复制代码 这里需要注意的是，在链式调用的最一定要加上一个catch来捕捉链条中可能出现的错误！ 六、Promise链式调用可以处理的一个业务场景当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了。 我们使用axios来演示，axios本身就使用Promise进行封装，代码如下： 12345678910111213141516let request &#x3D; (url) &#x3D;&gt; &#123; let result &#x3D; axios.get(url) &#x2F;&#x2F;result是Promise对象 result.then(response &#x3D;&gt; &#123; return response &#125;).catch(error &#x3D;&gt; &#123; throw new Error(&#39;出错了!&#39;) &#125;)&#125;request(url0).then(response &#x3D;&gt; &#123; return request(response.data.link)&#125;).then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(error &#x3D;&gt; &#123; console.log(error)&#125;)","tags":[]},{"title":"V8引擎垃圾内存回收原理解析","date":"2019-12-27T01:53:43.558Z","path":"2019/12/27/V8引擎垃圾内存回收原理解析/","text":"V8 引擎垃圾内存回收原理解析JS 语言不像 C/C++, 让程序员自己去开辟或者释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。 作为一名资深的前端工程师，对于JS内存回收的机制是需要非常清楚，以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习 这其中的机制，也对我们深入理解JS的闭包特性、以及对内存的高效使用，都有很大的帮助。 V8 内存限制在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，在64位系统下， V8最多只能分配1.4G, 在 32 位系统中，最多只能分配0.7G。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到 一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。 我们知道对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析 堆内存的垃圾回收。 所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存 已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。 那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？ 究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。 首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的: 以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。 可见其耗时之久，而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的 选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。 不过，如果你想调整这个内存的限制也不是不行。配置命令如下: 12&#x2F;&#x2F; 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存node --max-old-space-size&#x3D;2048 xxx.js 或者 12&#x2F;&#x2F; 这是调整新生代这部分的内存，单位是 KB。node --max-new-space-size&#x3D;2048 xxx.js 新生代内存的回收V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存 之和。 根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。 首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好 理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。 那好了，新生代的垃圾回收是怎么做的呢？ 首先将新生代内存空间一分为二: 其中From部分表示正在使用的内存，To 是目前闲置的内存。 当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。 当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。 那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？ 注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景: 16e62eaf5946cfc5 深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配， 这种零散的空间也叫做内存碎片。刚刚介绍的新生代垃圾回收算法也叫Scavenge算法。 Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子: 是不是整齐了许多？这样就大大方便了后续连续空间的分配。 不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。 老生代内存的回收刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。 发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升: 已经经历过一次 Scavenge 回收。 To（闲置）空间的内存占用超过25%。 现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用Scavenge算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是 劳民伤财？ 那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？ 第一步，进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象， 对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。 当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？ 第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。 16e62eb43245357f 由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。 增量标记由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。 那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就”歇”一下，就js应用逻辑执行一会儿， 然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。 经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。 JS垃圾回收的原理就介绍到这里了，其实理解起来是非常简单的，重要的是理解它为什么要这么做，而不仅仅是如何做的，希望这篇总结能够对你有所启发","tags":[]},{"title":"Vue代理proxyTable设置","date":"2019-12-26T09:40:01.198Z","path":"2019/12/26/Vue代理proxyTable设置/","text":"Vue 代理 proxyTable 设置背景：vue项目在本地开发默认打开localhost:8081，但是后端请求地址和本地产生跨域，怎样快速的在本地进行调接口调试？vue-cli自带的proxyTable 可以解决本地开发跨域问题 我们在项目中的后端路由，都带有 /server/ 的prefix 那么我们在config里配置 proxyTable 可以这样写： 123456789proxyTable: &#123; &#39;&#x2F;server&#39;: &#123; target: &#39;http:&#x2F;&#x2F;后端地址:7002&#39;, changeOrigin: true, pathRewrite: &#123; &#39;&#x2F;server&#39;: &#39;&#x2F;server&#x2F;&#39; &#125; &#125; &#125;, 这样本地就可以调用后端的接口进行调试了，记住，改完config文件要重新npm run dev ps：此方法仅限用于开发环境，不适合生产环境，生产环境可以用nginx进行代理","tags":[]},{"title":"JavaScript执行机制","date":"2019-12-26T09:35:01.855Z","path":"2019/12/26/JavaScript执行机制/","text":"1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data &#x3D; [];$.ajax(&#123; url:www.javascript.com, data:data, success:() &#x3D;&gt; &#123; console.log(&#39;发送成功!&#39;); &#125;&#125;)console.log(&#39;代码执行结束&#39;); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行： 123setTimeout(() &#x3D;&gt; &#123; console.log(&#39;延时3秒&#39;);&#125;,3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子： 1234setTimeout(() &#x3D;&gt; &#123; task();&#125;,3000)console.log(&#39;执行console&#39;); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12&#x2F;&#x2F;执行console&#x2F;&#x2F;task() 去验证一下，结果正确！然后我们修改一下前面的代码： 12345setTimeout(() &#x3D;&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 12345678910&#x2F;&#x2F;代码1console.log(&#39;先执行这里&#39;);setTimeout(() &#x3D;&gt; &#123; console.log(&#39;执行啦&#39;)&#125;,0);&#x2F;&#x2F;代码2console.log(&#39;先执行这里&#39;);setTimeout(() &#x3D;&gt; &#123; console.log(&#39;执行啦&#39;)&#125;,3000); 代码1的输出结果是： 12&#x2F;&#x2F;先执行这里&#x2F;&#x2F;执行啦 代码2的输出结果是： 123&#x2F;&#x2F;先执行这里&#x2F;&#x2F; ... 3s later&#x2F;&#x2F; 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log(&#39;setTimeout&#39;);&#125;)new Promise(function(resolve) &#123; console.log(&#39;promise&#39;);&#125;).then(function() &#123; console.log(&#39;then&#39;);&#125;)console.log(&#39;console&#39;); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 事件循环，宏任务，微任务的关系如图所示： 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log(&#39;1&#39;);setTimeout(function() &#123; console.log(&#39;2&#39;); process.nextTick(function() &#123; console.log(&#39;3&#39;); &#125;) new Promise(function(resolve) &#123; console.log(&#39;4&#39;); resolve(); &#125;).then(function() &#123; console.log(&#39;5&#39;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&#39;6&#39;);&#125;)new Promise(function(resolve) &#123; console.log(&#39;7&#39;); resolve();&#125;).then(function() &#123; console.log(&#39;8&#39;)&#125;)setTimeout(function() &#123; console.log(&#39;9&#39;); process.nextTick(function() &#123; console.log(&#39;10&#39;); &#125;) new Promise(function(resolve) &#123; console.log(&#39;11&#39;); resolve(); &#125;).then(function() &#123; console.log(&#39;12&#39;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后 javascript是一门单线程语言 Event Loop是javascript的执行机制","tags":[]},{"title":"项目常用JS方法封装","date":"2019-12-26T09:27:13.336Z","path":"2019/12/26/项目常用JS方法封装/","text":"001.输入一个值,返回其数据类型1234type &#x3D; para &#x3D;&gt; &#123; return Object.prototype.toString.call(para).slice(8,-1) &#125;qwe 002.冒泡排序升序 bubbleAsSort() 12345678910111213bubbleAsSort &#x3D; arr &#x3D;&gt; &#123; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; for (let j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp &#x3D; arr[j + 1]; arr[j + 1] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125; &#125; return arr;&#125;qwe 降序 bubbleDeSort() 12345678910111213bubbleDeSort &#x3D; arr &#x3D;&gt; &#123; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; for (let j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; let temp &#x3D; arr[j + 1]; arr[j + 1] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125; &#125; return arr;&#125;qwe 003.选择排序升序 selectAsSort() 12345678910111213141516selectAsSort &#x3D; arr &#x3D;&gt; &#123; let minIndex, temp; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; minIndex &#x3D; i; for (let j &#x3D; i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex &#x3D; j; &#125; &#125; temp &#x3D; arr[i]; arr[i] &#x3D; arr[minIndex]; arr[minIndex] &#x3D; temp; &#125; return arr;&#125;qwe 降序 selectDeSort() 12345678910111213141516selectDeSort &#x3D; arr &#x3D;&gt; &#123; let minIndex, temp; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; minIndex &#x3D; i; for (let j &#x3D; i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &gt; arr[minIndex]) &#123; minIndex &#x3D; j; &#125; &#125; temp &#x3D; arr[i]; arr[i] &#x3D; arr[minIndex]; arr[minIndex] &#x3D; temp; &#125; return arr;&#125;qwe 004.插入排序升序 insertAsSort() 1234567891011121314insertAsSort &#x3D; arr &#x3D;&gt; &#123; let current, preIndex; for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; current &#x3D; arr[i]; preIndex &#x3D; i - 1; while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] &#x3D; arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] &#x3D; current; &#125; return arr;&#125;qwe 降序 insertDeSort() 1234567891011121314insertDeSort &#x3D; arr &#x3D;&gt; &#123; let current, preIndex; for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; current &#x3D; arr[i]; preIndex &#x3D; i - 1; while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &lt; current) &#123; arr[preIndex + 1] &#x3D; arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] &#x3D; current; &#125; return arr;&#125;qwe 005.阶乘12345678factorial &#x3D; num &#x3D;&gt; &#123; let count &#x3D; 1; for (let i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; count *&#x3D; i; &#125; return count;&#125;qwe 006.两个数之间累乘12345678910111213141516multBetride &#x3D; (x, y) &#x3D;&gt; &#123; let count; if (x &lt; y) &#123; count &#x3D; x; for (let i &#x3D; x + 1; i &lt;&#x3D; y; i++) &#123; count *&#x3D; i; &#125; return count; &#125; else &#123; count &#x3D; y; for (let i &#x3D; y + 1; i &lt;&#x3D; x; i++) &#123; count *&#x3D; i; &#125; return count; &#125;&#125; 007.累加（）里面可以放N个实参 1234567function cumsum() &#123; let sum &#x3D; 0; for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123; sum +&#x3D; arguments[i]; &#125; return sum;&#125; 008.计时器(计算代码块(函数)执行时间)无参 computeTime(f) 1234567computeTime &#x3D; code &#x3D;&gt; &#123; let startTime &#x3D; new Date().getTime(); code(); let endTime &#x3D; new Date().getTime(); let time &#x3D; endTime - startTime; return time;&#125; 有参 computeTime(f) 使用方法:computeTime(f,参数1,参数2……) 1234567891011computeTime &#x3D; f &#x3D;&gt; &#123; let startTime &#x3D; new Date().getTime(); let p &#x3D; []; for (let i &#x3D; 1; i &lt; arguments.length; i++) &#123; p.push(arguments[i]) &#125; f.apply(null, p) let endTime &#x3D; new Date().getTime(); let Time &#x3D; endTime - startTime; return Time;&#125; 009.数组去重12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152arrDemp1 &#x3D; arr &#x3D;&gt; &#123; let newArr &#x3D; []; let m &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; let n &#x3D; arr[i]; if (m[n]) &#123; &#125; else &#123; newArr.push(arr[i]); m[n] &#x3D; true; &#125; &#125; return newArr;&#125;&#x2F;&#x2F;遍历数组法arrDemp2 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F;indexOf()方法可返回某个指定的字符串或数组值在字符串或数组中首次出现的位置，若不在其中则返回-1 if (temp.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) temp.push(arr[i]); &#125; return temp;&#125;&#x2F;&#x2F;排序法arrDemp3 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; arr.sort(); temp.push(arr[0]); &#x2F;&#x2F;因为数组已经经过排序，所以重复元素一定相邻，判断当前数组第i个元素与temp的最后一个元素是否相等，不相等时才复制元素 for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; if (arr[i] !&#x3D; temp[temp.length - 1]) temp.push(arr[i]); &#125; return temp;&#125;&#x2F;&#x2F;对象法arrDemp4 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; let json &#x3D; &#123;&#125;; &#x2F;&#x2F;将当前数组的元素值当作对象的属性，遍历数组，比对对象，如果对象的这个属性不存在则将当前数组元素复制到临时数组，并添加该属性且将属性值赋值为1 for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (!json[arr[i]]) &#123;&#x2F;&#x2F;如果对象没有该属性 temp.push(arr[i]); json[arr[i]] &#x3D; 1;&#x2F;&#x2F;添加属性，将属性值赋值为1 &#125; &#125; return temp;&#125; 也可以使用ES6中的new Set，一步到位 1234let arr &#x3D; [1,2,3,5,4,5,4,3,6]let arrDemp &#x3D; new Set(arr) &#x2F;&#x2F;arrDemp是一个对象let newArr &#x3D; [...arrDemp] &#x2F;&#x2F;把arrDemp转化成数组console.log(newArr); 010.数组对象去重将对象数组中属性相同的项去重 1234567891011121314151617181920212223242526272829303132333435&#x2F;** objArr 对象数组* para 将要进行去重的字段(String类型)*&#x2F;测试数据：let objArr &#x3D; [&#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;a&#39;, age: 2 &#125;, &#123; name: &#39;b&#39;, age: 2 &#125;]console.log(objArrDemp1(objArr,&#39;name&#39;)); &#x2F;&#x2F; [ &#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;b&#39;, age: 2 &#125; ]console.log(objArrDemp1(objArr,&#39;age&#39;)); &#x2F;&#x2F; [ &#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;a&#39;, age: 2 &#125; ]objArrDemp1 &#x3D; (objArr, para) &#x3D;&gt; &#123; let result &#x3D; []; let temp &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; objArr.length; i++) &#123; let parameter &#x3D; objArr[i][para]; if (temp[parameter]) &#123; continue;&#x2F;&#x2F;不继续执行接下来的代码，跳转至循环开头 &#125; temp[parameter] &#x3D; true;&#x2F;&#x2F;为temp添加此属性（parameter）且将其值赋为true result.push(objArr[i]);&#x2F;&#x2F;将这一项复制到结果数组result中去 &#125; return result;&#125;objArrDemp2 &#x3D; (objArr, para) &#x3D;&gt; &#123; let hash &#x3D; &#123;&#125;; &#x2F;&#x2F;reduce方法有两个参数，第一个参数是一个callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。 objArr &#x3D; objArr.reduce(function (item, next) &#123;&#x2F;&#x2F;这是针对数组项操作的函数，对于每个数组项，reduce方法都会将其调用一次 hash[next[para]] ? &#39;&#39; : hash[next[para]] &#x3D; true &amp;&amp; item.push(next); return item; &#125;, []);&#x2F;&#x2F;初始值是一个空对象，使用reduce方法返回的是空对象通过叠加执行之后的结果 return objArr;&#125; 011.统计数组中各个元素出现的次数12345678910111213141516staArrNum &#x3D; arr &#x3D;&gt; &#123; let obj &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; let m &#x3D; arr[i]; if (obj.hasOwnProperty(m)) &#123; obj[m] +&#x3D; 1; &#125; else &#123; obj[m] &#x3D; 1; &#125; &#125; return obj;&#125;let arr &#x3D; [1, 2, 3, 6, 5, 3, 2, 1, 2, 3, 2, 1]console.log(staArrNum(arr)); &#x2F;&#x2F; &#123; &#39;1&#39;: 3, &#39;2&#39;: 4, &#39;3&#39;: 3, &#39;5&#39;: 1, &#39;6&#39;: 1 &#125; 012.在数组中找指定的元素,返回下标12345678910111213arrFinNum &#x3D; function (arr,num) &#123; let index &#x3D; -1; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (num &#x3D;&#x3D; arr[i]) &#123; index &#x3D; i; break; &#125; &#125; return index;&#125;let arr &#x3D; [1,2,3,4,5,6]console.log(arrFinNum(arr,4)); &#x2F;&#x2F; 3 013.删除数组中的元素123456delArrNum &#x3D; (arr,val) &#x3D;&gt; &#123; let index &#x3D; arrFinNum(arr, val) &#x2F;&#x2F;调用了前面自行添加的arrFinNum方法 if (index !&#x3D; -1) &#123; return arr.splice(index, 1); &#125;&#125; 示例 123456789101112131415161718192021let arr &#x3D; [1, 2, 3, 4, 5, 6]arrFinNum &#x3D; (arr, num) &#x3D;&gt; &#123; let index &#x3D; -1; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (num &#x3D;&#x3D; arr[i]) &#123; index &#x3D; i; break; &#125; &#125; return index;&#125;delArrNum &#x3D; (arr,val) &#x3D;&gt; &#123; let index &#x3D; arrFinNum(arr, val) &#x2F;&#x2F;调用了前面自行添加的arrFinNum方法 if (index !&#x3D; -1) &#123; return arr.splice(index, 1); &#125;&#125;console.log(delArrNum(arr,2)); &#x2F;&#x2F; [ 2 ] 014.数字超过9显示省略号12345678num_filter &#x3D; val &#x3D;&gt;&#123; val &#x3D; val?val-0:0; if (val &gt; 9 ) &#123; return &quot;…&quot; &#125;else&#123; return val; &#125;&#125; 015.数字超过99显示99+12345678ninenum_filter &#x3D; val &#x3D;&gt;&#123; val &#x3D; val?val-0:0; if (val &gt; 99 ) &#123; return &quot;99+&quot; &#125;else&#123; return val; &#125;&#125; 016.银行卡号分割12345bank_filter &#x3D; val &#x3D;&gt;&#123; val +&#x3D; &#39;&#39;; val &#x3D; val.replace(&#x2F;(\\s)&#x2F;g,&#39;&#39;).replace(&#x2F;(\\d&#123;4&#125;)&#x2F;g,&#39;$1 &#39;).replace(&#x2F;\\s*$&#x2F;,&#39;&#39;); return val;&#125; 017.二分查找1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F;非递归实现binarySearch &#x3D; (arr, key) &#x3D;&gt; &#123; let high &#x3D; arr.length - 1, low &#x3D; 0; while (low &lt;&#x3D; high) &#123; let m &#x3D; Math.floor((high + low) &#x2F; 2); if (arr[m] &#x3D;&#x3D; key) &#123; return m; &#125; if (key &gt; arr[m]) &#123; low &#x3D; m + 1; &#125; else &#123; high &#x3D; m - 1; &#125; &#125; return false;&#125;let arr &#x3D; [-1, 1, 3, 4, 5, 8, 32, 234, 12, 42];console.log(binarySearch(arr, 4));&#x2F;&#x2F;递归实现binarySearch &#x3D; (arr, low, high, key) &#x3D;&gt; &#123; if (low &gt; high) &#123; return -1; &#125; let mid &#x3D; parseInt((high + low) &#x2F; 2); if (arr[mid] &#x3D;&#x3D; key) &#123; return mid; &#125; else if (arr[mid] &gt; key) &#123; high &#x3D; mid - 1; return binarySearch(arr, low, high, key); &#125; else if (arr[mid] &lt; key) &#123; low &#x3D; mid + 1; return binarySearch(arr, low, high, key); &#125;&#125;;let arr &#x3D; [-1, 1, 3, 4, 5, 8, 32, 234, 12, 42];console.log(binarySearch(arr, 0, 13, 5)); 018.防抖与节流123456789101112131415161718192021222324252627282930313233343536373839&#x2F;** * 函数防抖 (只执行最后一次点击) *&#x2F;Debounce &#x3D; (fn, t) &#x3D;&gt; &#123; let delay &#x3D; t || 500; let timer; return function () &#123; let args &#x3D; arguments; if(timer)&#123; clearTimeout(timer); &#125; timer &#x3D; setTimeout(() &#x3D;&gt; &#123; timer &#x3D; null; fn.apply(this, args); &#125;, delay); &#125;&#125;;&#x2F;* * 函数节流 *&#x2F;Throttle &#x3D; (fn, t) &#x3D;&gt; &#123; let last; let timer; let interval &#x3D; t || 500; return function () &#123; let args &#x3D; arguments; let now &#x3D; +new Date(); if (last &amp;&amp; now - last &lt; interval) &#123; clearTimeout(timer); timer &#x3D; setTimeout(() &#x3D;&gt; &#123; last &#x3D; now; fn.apply(this, args); &#125;, interval); &#125; else &#123; last &#x3D; now; fn.apply(this, args); &#125; &#125;&#125;; 019.深拷贝1234567891011121314151617181920212223242526272829deepClone &#x3D; source &#x3D;&gt; &#123; const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;; &#x2F;&#x2F; 判断复制的目标是数组还是对象 for (let keys in source) &#123; &#x2F;&#x2F; 遍历目标 if (source.hasOwnProperty(keys)) &#123; if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123; &#x2F;&#x2F; 如果值是对象，就递归一下 targetObj[keys] &#x3D; source[keys].constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;; targetObj[keys] &#x3D; deepClone(source[keys]); &#125; else &#123; &#x2F;&#x2F; 如果不是，就直接赋值 targetObj[keys] &#x3D; source[keys]; &#125; &#125; &#125; return targetObj;&#125;let str1 &#x3D; &#123; arr: [1, 2, 3], obj: &#123; key: &#39;value&#39; &#125;, fn: function () &#123; return 1; &#125;&#125;;let str3 &#x3D; deepClone(str1);console.log(str3 &#x3D;&#x3D;&#x3D; str1); &#x2F;&#x2F; falseconsole.log(str3.obj &#x3D;&#x3D;&#x3D; str1.obj); &#x2F;&#x2F; falseconsole.log(str3.fn &#x3D;&#x3D;&#x3D; str1.fn); &#x2F;&#x2F; true 020.获取视口尺寸需要在HTML文件中运行 1234567891011121314151617181920212223function getViewportOffset() &#123; if (window.innerWidth) &#123; return &#123; w: window.innerWidth, h: window.innerHeight &#125; &#125; else &#123; &#x2F;&#x2F; ie8及其以下 if (document.compatMode &#x3D;&#x3D;&#x3D; &quot;BackCompat&quot;) &#123; &#x2F;&#x2F; 怪异模式 return &#123; w: document.body.clientWidth, h: document.body.clientHeight &#125; &#125; else &#123; &#x2F;&#x2F; 标准模式 return &#123; w: document.documentElement.clientWidth, h: document.documentElement.clientHeight &#125; &#125; &#125;&#125; 021.数字前补零1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;*** num为你想要进行填充的数字* length为你想要的数字长度*&#x2F;&#x2F;&#x2F;迭代方式实现padding1&#x3D;(num, length)&#x3D;&gt; &#123; for(let len &#x3D; (num + &quot;&quot;).length; len &lt; length; len &#x3D; num.length) &#123; num &#x3D; &quot;0&quot; + num; &#125; return num;&#125;&#x2F;&#x2F;递归方式实现padding2&#x3D;(num, length) &#x3D;&gt;&#123; if((num + &quot;&quot;).length &gt;&#x3D; length) &#123; return num; &#125; return padding2(&quot;0&quot; + num, length)&#125;&#x2F;&#x2F;转为小数padding3&#x3D;(num, length)&#x3D;&gt; &#123; let decimal &#x3D; num &#x2F; Math.pow(10, length); &#x2F;&#x2F;toFixed指定保留几位小数 decimal &#x3D; decimal.toFixed(length) + &quot;&quot;; return decimal.substr(decimal.indexOf(&quot;.&quot;)+1);&#125;&#x2F;&#x2F;填充截取法padding4&#x3D;(num, length)&#x3D;&gt; &#123; &#x2F;&#x2F;这里用slice和substr均可 return (Array(length).join(&quot;0&quot;) + num).slice(-length);&#125;&#x2F;&#x2F;填充截取法padding5&#x3D;(num, length)&#x3D;&gt; &#123; let len &#x3D; (num + &quot;&quot;).length; let diff &#x3D; length+1 - len; if(diff &gt; 0) &#123; return Array(diff).join(&quot;0&quot;) + num; &#125; return num;&#125; 022.字符替换可以替换任意数字和符号 12345678910111213&#x2F;*** str 表示将要替换的字符串* l 表示你将要替换的字符* r 表示你想要替换的字符*&#x2F;transFormat &#x3D; (str, l, r) &#x3D;&gt; &#123; let reg &#x3D; new RegExp(l, &#39;g&#39;) &#x2F;&#x2F; g表示全部替换，默认替换第一个 str &#x3D; str.replace(reg, r) return str&#125;console.log(transFormat(&#39;2019-12-13&#39;, &#39;-&#39;, &#39;&#x2F;&#39;)); &#x2F;&#x2F; 2019&#x2F;12&#x2F;13console.log(transFormat(&#39;2019-12-13&#39;, &#39;-&#39;, &#39;&#39;)); &#x2F;&#x2F; 20191213 023.在字符串指定位置插入字符1234567891011&#x2F;*** character 原字符串（String）* site 要插入的字符的位置 （Number）* newStr 想要插入的字符 （String）*&#x2F;insertStr &#x3D; (character, site, newStr) &#x3D;&gt; &#123; return character.slice(0, site) + newStr + character.slice(site);&#125;console.log(insertStr(&#39;20191217&#39;,4,&#39;-&#39;)); &#x2F;&#x2F; 2019-1217 024.字符串反转处理分割123456789101112&#x2F;*** str 是你将要进行处理的字符串(String)* under 是你根据什么字符处理(String)* event 是你根据什么字符把处理结果分割(String)*&#x2F;keyCharacterMap &#x3D; (str,under,event) &#x3D;&gt; &#123; return str.split(under).reverse().join(event)&#125;console.log(keyCharacterMap(&#39;hello world&#39;,&#39;&#39;,&#39;&#39;)); &#x2F;&#x2F; dlrow ollehconsole.log(keyCharacterMap(&#39;hello world&#39;,&#39; &#39;,&#39;-&#39;)); &#x2F;&#x2F; world-hello 025.格式转换：base64转file1234567891011121314151617&#x2F;*** base64 base64* filename 转换后的文件名*&#x2F;base64ToFile &#x3D; (base64, filename) &#x3D;&gt; &#123; let arr &#x3D; base64.split(&quot;,&quot;), mime &#x3D; arr[0].match(&#x2F;:(.*?);&#x2F;)[1], bstr &#x3D; atob(arr[1]), n &#x3D; bstr.length, u8arr &#x3D; new Uint8Array(n); while (n--) &#123; u8arr[n] &#x3D; bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123; type: mime &#125;);&#125; 026.格式转换：base64转blob1234567891011base64ToBlob &#x3D; base64 &#x3D;&gt; &#123; let arr &#x3D; base64.split(&#39;,&#39;), mime &#x3D; arr[0].match(&#x2F;:(.*?);&#x2F;)[1], bstr &#x3D; atob(arr[1]), n &#x3D; bstr.length, u8arr &#x3D; new Uint8Array(n); while (n--) &#123; u8arr[n] &#x3D; bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123; type: mime &#125;);&#125;; 027.格式转换：blob转file12345blobToFile &#x3D; (blob, fileName) &#x3D;&gt; &#123; blob.lastModifiedDate &#x3D; new Date(); blob.name &#x3D; fileName; return blob;&#125;;","tags":[]}]