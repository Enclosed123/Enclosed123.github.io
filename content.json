[{"title":"webpack性能优化","date":"2020-01-06T15:39:41.834Z","path":"2020/01/06/webpack性能优化/","text":"转载自掘金战戟飞红https://juejin.im/post/5dfb69aaf265da339260c0d8#heading-22Webapck 性能优化上一章我们介绍了Webpack常用配置和大致优化思路，这一章节我们来看一下具体怎么优化(未完待续，大佬们可以在评论中提点意见) git地址：github.com/jxs7754/dem… 1. 构建速度优化 高版本的node和Webpack 开启多进程，加快解析、压缩速度 分包，分离基础包 利用缓存来提升二次构建速度 减少文件搜索范围 速度分析：使用speed-measure-webpack-plugin12345678const SpeedMeasureWebpackPlugin &#x3D; reqire(&#39;speed-measure-webpack-plugin&#39;);const smp &#x3D; new SeedMeasureWebpackPlugin();const webpackCofig &#x3D; smp.wrap(&#123; plugins:[ &#x2F;&#x2F; MyPlugin(), ]&#125;)复制代码 可以分析整个打包的总耗时，可以查看每个loader和plugins的耗时情况； 1.1 使用高版本的Node和Webapck V8引擎的升级优化 webpack4 默认使用更快md4 hash算法 webpacks AST 可以直接从 loader 传递给 AST，减少解析时间 使用字符串方法替代正则表达式 1.2 开启多进程thread-loader1234567891011121314151617181920&#123; module:&#123; rules: [ &#123; test: &#39;&#x2F;.js$&#x2F;&#39;, use: [ &#123; loader: &#39;thread-loader&#39;, options:&#123; workers： 3， &#125; &#125;， &#39;babel-loader&#39; ] &#125; ] &#125; &#125;复制代码 HappyPack(作者已经不再维护)1234567891011121314151617181920212223const HappyPack &#x3D; require(&#39;happypack&#39;);exports.module &#x3D; &#123; rules: [ &#123; test: &#x2F;.js$&#x2F;, &#x2F;&#x2F; 1) replace your original list of loaders with &quot;happypack&#x2F;loader&quot;: &#x2F;&#x2F; loaders: [ &#39;babel-loader?presets[]&#x3D;es2015&#39; ], use: &#39;happypack&#x2F;loader&#39;, include: [ &#x2F;* ... *&#x2F; ], exclude: [ &#x2F;* ... *&#x2F; ] &#125; ]&#125;;exports.plugins &#x3D; [ &#x2F;&#x2F; 2) create the plugin: new HappyPack(&#123; &#x2F;&#x2F; 3) re-add the loaders you replaced above in #1: loaders: [ &#39;babel-loader?presets[]&#x3D;es2015&#39; ] &#125;)];复制代码 多线程压缩1234567891011121314&#x2F;&#x2F; terser-webpack-pluginmodule.exports &#x3D; &#123; optimization: &#123; minimizer: &#123; new TerserPlugin(&#123; parallel: 4, &#125;) &#125; &#125; &#125;&#x2F;&#x2F; 下面这俩个插件可以配置多线程&#x2F;&#x2F; parallel-uglify-plugin &#x2F;&#x2F; uglifyjs-webpack-plugin 复制代码 1.3 分包 设置Externals,使用 html-webpack-externals-plugin将基础包（vue vue-router）通过CDN，不打入包中。 123456789101112131415new HtmlWebpackExternalsPlugin(&#123; externals: [ &#123; module: &#39;react&#39;, entry: &#39;https:&#x2F;&#x2F;xxx&#x2F;react.min.js&#39;, global: &#39;React&#39;, &#125;, &#123; module: &#39;react-dom&#39;, entry: &#39;https:&#x2F;&#x2F;xxx&#x2F;react-dom.min.js&#39;, global: &#39;ReactDOM&#39;, &#125;, ],&#125;),复制代码 没有CDN的情况 可以预编译 DllPlugin进行分包，DllReferencePlugin对manifest.json 引用 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 分包module.exports &#x3D; &#123; mode: &#39;production&#39;, entry: &#123; vue: [&#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;, &#39;vue-router&#39;, &#39;vuex&#39;], axios: [&#39;axios&#39;, &#39;qs&#39;], &#x2F;&#x2F; ui: [&#39;element-ui&#39;], &#125;, output: &#123; filename: &#39;[name]_[chunkhash:8].dll.js&#39;, path: path.join(__dirname, &#39;build&#39;), library: &#39;[name]&#39;, &#125;, plugins: [ new CleanWebpackPlugin(), new webpack.DllPlugin(&#123; name: &#39;[name]_[hash]&#39;, path: path.join(__dirname, &#39;build&#x2F;[name].json&#39;), &#125;), ],&#125;;&#x2F;&#x2F; 引用module.exports &#x3D; &#123; plugins: [ ...[&#39;vue&#39;, &#39;axios&#39;].map((item) &#x3D;&gt; new webpack.DllReferencePlugin(&#123; context: path.join(__dirname, &#39;.&#x2F;build&#39;), manifest: require(&#96;.&#x2F;build&#x2F;$&#123;item&#125;.json&#96;), &#125;)), ] &#125;复制代码 1.4 缓存 缓存是为了二次构建时候，加快构建 babel-loader 开启缓存1234567&#123; loader: &#39;babel-loader&#39;, options:&#123; cacheDirectory: true &#125;&#125; 复制代码 terser-webpack-plugin 开启缓存12345678910111213&#123; optimization: &#123; minimizer: &#123; new TerserPlugin(&#123; &#x2F;&#x2F; 多线程 parallel: 4, &#x2F;&#x2F; 缓存 cache: true, &#125;) &#125; &#125; &#125;复制代码 hard-source-webpack-plugin 或者 cache-loader1.5 减少文件搜素范围优化loader配置由于 Loader 对文件的转换操作很耗时，所以需要让尽可能少的文件被 Loader 处理。可以通过 test/include/exclude 三个配置项来命中 Loader 要应用规则的文件。 使用合理的alias在实战项目中经常会依赖一些庞大的第三方模块，以 Vue 库为例，发布出去的 Vue 库中包含多套代码, vue.runtime.esm.js 中只包含运行时的代码。如果不用template选项可以直接用这个减少打包体积。 12345678module.exports &#x3D; &#123; resolve: &#123; alias: &#123; &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.runtime.esm.js&#39;, &#125; &#125; &#125;复制代码 优化resolve.modules配置resolve.modules 的默认值是［’node_modules’］，含义是先去当前目录的node_modules目录下去找我们想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules中找，以此类推。当安装的第三方模块都放在项目根目录的 node_modules 目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找。 123456module.exports &#x3D; &#123; resolve: &#123; modules: [path.resolve( __dirname,&#39;node modules&#39;)] &#125; &#125;复制代码 优化resolve.mainFields配置在安装的第三方模块中都会有一个package.json文件，用于描述这个模块的属性,其中可以存在多个字段描述入口文件，原因是某些模块可以同时用于多个环境中，针对不同的运行环境需要使用不同的代码。 segmentfault.com/a/119000001… 优化resolve.extensions配置在导入语句没带文件后缀时，Webpack会自动带上后缀去尝试询问文件是否存在。如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以resolve.extensions的配置也会影响到构建的性能在配置resolve.extensions时需要遵守以下几点，以做到尽可能地优化构建性能。 后缀列表尽可能小 频率出现高的文件后缀优先放前面 源码中写导入语句时，尽可能带上后缀 1234 &#123; extensions: [&#39;.js&#39;], &#125;,复制代码 2. 构建体积优化 提取公共代码、分割代码、按需加载、懒加载 tree-shaking scope-hoisting 删除无用的css 动态polyfill 代码压缩，开启Gzip压缩 体积分析 webpack-bundle-analyzer 可以分析依赖的第三方模块的大小、业务里面组件的代码大小 1234567const BoundAnalysisPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;module.exports &#x3D; &#123; plugins: [ new BoundAnalysisPlugin(), ]&#125;复制代码 2.1 提取公共代码、分割代码、按需加载、懒加载12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; 组件按需加载import &#123;Button&#125; from &#39;element-ui&#39;;&#x2F;&#x2F; 模块按需加载import &#123;cloneDeep&#125; from &#39;lodash-es&#39;;&#x2F;&#x2F; Vue 路由懒加载const Foo &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;group-foo&quot; *&#x2F; &#39;.&#x2F;Foo.vue&#39;)复制代码optimization: &#123; splitChunks: &#123; chunks: &#39;all&#39;, minSize: 30000, minRemainingSize: 0, maxSize: 0, minChunks: 1, maxAsyncRequests: 6, maxInitialRequests: 4, automaticNameDelimiter: &#39;~&#39;, automaticNameMaxLength: 30, cacheGroups: &#123; vendors: &#123; test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;复制代码 2.2 tree-shaking 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉。 注意事项： mode: production 默认开启 babel设置 modules:false, 必须使用ES6的语法 2.3 删除无用的css 使用 purgecss-webpack-plugin 配合 mini-css-extract-plugin 使用 123456789101112131415161718192021222324252627282930313233const config &#x3D; &#123; module:&#123; rules: [ &#123; test: &#39;&#x2F;.scss$&#x2F;&#39;, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;, &#123; loader: &#39;postcss-loader&#39;, options: &#123; plugins: () &#x3D;&gt; [ &#x2F;&#x2F; 自动扩展css require(&#39;autoprefixer&#39;)(), ], &#125;, &#125;, &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: getAssetPath( &#96;css&#x2F;[name]_[contenthash:8]&#39;&#125;.css&#96;, ), &#125;), new PurgecssPlugin(&#123; paths: glob.sync(&#96;$&#123;PATHS.src&#125;&#x2F;**&#x2F;*&#96;, &#123; nodir: true &#125;), &#125;), ]&#125;复制代码 2.4 动态polyfill 方案 优点 缺点 babel-polyfill 大而全 体积太大 @babel/plugin-transform-runtime 只polyfill用到的方法和类，体积较小 不能polyfill原型上的方法 polyfill-service 只返回客户需要的polyfill 国内奇葩浏览器 2.5 Scope-Hoisting ModuleConcatenationPlugin 现在webpack4在mode 不等于none都支持 2.6 图片压缩，代码压缩，还可以开启Gzip压缩 使用 image-webpack-loader进行图片压缩 3. 加载优化3.1 预加载 使用 @vue/preload-webpack-plugin 实现代码预加载 1234567891011121314const config &#x3D; &#123; plugins: [ new PreloadPlugin(&#123; rel: &#39;preload&#39;, include: &#39;initial&#39;, fileBlacklist: [&#x2F;\\.map$&#x2F;, &#x2F;hot-update\\.js$&#x2F;], &#125;), new PreloadPlugin(&#123; rel: &#39;prefetch&#39;, include: &#39;asyncChunks&#39;, &#125;), ]&#125;复制代码 3.2 使用文件指纹，浏览器缓存 Hash：和整个项⽬的构建相关，只要项⽬文件有修改，整个项⽬构建的 hash 值就会更改 Chunkhash：和 webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值 Contenthash：根据文件内容来定义 hash ，文件内容不不变，则 contenthash 不不变 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; js&#123; output: &#123; filename: &#39;[name]_[chunkhash:8].js&#39; &#125; &#125;&#x2F;&#x2F; css&#x2F;&#x2F; MiniCssExtractPlugin&#123; plugins:[ new MiniCssExtractPlugin(&#123; filename: &#39;[name]_[contenthash:8].css&#39; &#125;) ]&#125;&#x2F;&#x2F; 图片 &#x2F;&#x2F; file-loader 使用hash（这里的hash是根据内容生成的，默认是md5）&#123; module:&#123; rules:[ &#123; test: &#x2F;\\.(png|svg|jpg|gif)$&#x2F;, use: [&#123; loader: &#39;file-loader’, options: &#123; name: &#39;img&#x2F;[name][hash:8].[ext] &#39; &#125; &#125;] &#125; ] &#125;&#125;","tags":[]},{"title":"样式和兼容问题","date":"2020-01-05T05:24:54.407Z","path":"2020/01/05/样式和兼容问题/","text":"写在前面移动开发时代，前端同学刚刚送别了让人头秃的IE浏览器，却发现憧憬已久的移动互联网时代并不是想象中那般美好。各种棘手的系统兼容问题和浏览器兼容问题怎么也让人高兴不起来。作为一名工作不足3年的前端程序媛，始终相信好记性不如烂笔头。每次在项目开发过程中踩到的坑，都习惯性地记录了下来。昨日一瞥竟积少成多，稍感诧异。因此分享出来，希望对大家能有所帮助。 样式问题1、父元素设置了border-radius，子元素应用了transform，并且父元素设置了overflow:hidden，但是却失效？123456&#x2F;&#x2F; 给父元素设置 &#123; position:relative; z-index:1;&#125;复制代码 2、设置input 文本框的 placeholder 的颜色1234input::-webkit-input-placeholder&#123; color:rgba(144,147,153,1);&#125;复制代码 3、如何设置body背景色，height:100%,不生效？12345678910同时设置html，body的高度html,body&#123; height:100%；&#125; 或body&#123; height: 100vh; &#x2F;&#x2F; 代表占屏幕100%&#125;复制代码 4、一像素边框的问题1234567891011121314151617181920.row &#123; position: relative; &amp;:after&#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; width: 200%; border-bottom:1px solid #e6e6e6; color: red; height: 200%; -webkit-transform-origin: left top; transform-origin: left top; -webkit-transform: scale(0.5); transform: scale(0.5); pointer-events: none; &#x2F;* 防止点击触发 *&#x2F; box-sizing: border-box; &#125;&#125;复制代码 5、css属性touch-action:none;12该属性会导致安卓页面无法滚动，慎用!复制代码 6、去除ios 手机端input输入框的内阴影1234input&#123; -webkit-appearance: none; &#125;复制代码 7、安卓手机端div里面在包一层div，文字展示不居中的问题。12最好给div设置padding ，不固定高度和不设置line-height；复制代码 8、iOS端input输入框光标错位是由于fixed定位引起的，改成absolute就解决了。 1234.box&#123; position: absolute; &#125;复制代码 9、div实现背景色和背景图片同时存在123456&#123; background-color: #fff; background-image:url(&#39;..&#x2F;..&#x2F;assets&#x2F;img&#x2F;model-bg.png&#39;); background-repeat: no-repeat;&#125;复制代码 10、css 制作椭圆 border-radius可以单独设置水平和垂直的半径，只需要用一个斜杠（/）分隔这二个值就行。 此外我们还要知道border-radius不仅可以接受长度值还可以接受百分比值。 1234567&#123; width: 150px; height: 100px; border-radius: 50%&#x2F;50%; &#x2F;&#x2F;简写属性：border-radius:50% background: brown;&#125;复制代码 11、图片居中显示12object-fit: cover;复制代码 兼容问题1、iconfont 字体在钉钉应用里面加载不出来（或者是乱码）的问题引入iconfont字体的时候，需要按照顺序把字体依次引入。正确的顺序如下：123456789@font-face &#123; font-family: &quot;djicon&quot;; src: url(&#39;.&#x2F;iconfont.eot&#39;); &#x2F;* IE9*&#x2F; src: url(&#39;.&#x2F;iconfont.svg#iconfont&#39;) format(&#39;svg&#39;), &#x2F;* iOS 4.1- *&#x2F; url(&#39;.&#x2F;iconfont.woff&#39;) format(&#39;woff&#39;), &#x2F;* chrome、firefox *&#x2F; url(&#39;.&#x2F;iconfont.ttf&#39;) format(&#39;truetype&#39;); &#x2F;* chrome、firefox、opera、Safari, Android, iOS 4.2+*&#x2F;&#125;&#x2F;&#x2F; 参考文档：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Megasu&#x2F;p&#x2F;4305116.html复制代码 2、PC端ueditor 编辑的文案及图片拉伸问题，背景是 后端返回是html片段node - cheerio模块，操作dom字符串比较方便，实际案例：解决了 PC端图片在移动端展示的问题参考文档：www.jianshu.com/p/e6d73d8fa…www.npmjs.com/package/che… 1234567891011121314151617181920212223242526width: number &#x3D; 784 代表pc端宽度 regHtml(str: string)&#123; &#x2F;&#x2F; 参数是html片段 let _this &#x3D; this; const $ &#x3D; cheerio.load(str); $(&#39;img&#39;).each(function(index,element)&#123; let attr &#x3D; element.attribs &#x2F;&#x2F;元素的属性 &#x2F;&#x2F; 屏幕宽度 let docEl &#x3D; document.documentElement let clientWidth &#x3D; docEl.clientWidth if(attr.width)&#123; &#x2F;&#x2F;如果设置了宽 &#x2F;&#x2F; 图片宽度&#x2F;屏幕宽度的比例 let rate &#x3D; attr.width &#x2F;_this.width &#x2F;&#x2F;图片的宽高比例 let wh &#x3D; attr.width&#x2F;attr.height $(element).attr(&#39;height&#39;, _this.rate*clientWidth&#x2F;wh) $(element).attr(&#39;width&#39;, _this.rate*clientWidth) $(element).attr(&#39;style&#39;, &#39;&#39;) $(element).attr(&#39;class&#39;, &#39;img-skew&#39;) &#125; &#125;) return $.html() &#125;复制代码 3、IOS 点击input不聚焦问题。ios系统中点击Input输入框，没有反应，无法聚集光标，调不起键盘。 解决方案：强制性给加上点击事件，点击后给input框聚集光标。 1234cilckTextarea()&#123; document.getElementsByClassName(&#39;cont-inp&#39;)[0].focus();&#125;,复制代码 4、上传图片，iPhone7 iPhone7p在上传图片的时候，传不过去图片的name解决方案：手动添加图片name 123let data &#x3D; new FormData();data.append(&quot;fileName&quot;, file[0],file[0].name); 复制代码 5、ios微信打开网页键盘弹起后页面上滑，导致弹框里的按钮响应区域错位解决方案：手动把滚动条滚到底部写一个自定义指令。 12345678910import Vue from &#39;vue&#39;;Vue.directive(&#39;blur&#39;, &#123; &#39;bind&#39;(el) &#123; el.addEventListener(&quot;click&quot;, function()&#123; window.scrollTo(0,0); &#125;) &#125;&#125;); &#x2F;&#x2F;在点击页面提交按钮的时候，把滚动条滚到底部就OK了复制代码 6、微信浏览器调整字体后，页面错位。解决方案：阻止页面字体自动调整大小 1234567891011121314151617181920212223242526&#x2F;&#x2F; 安卓：(function() &#123; if (typeof WeixinJSBridge &#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke &#x3D;&#x3D; &quot;function&quot;) &#123; handleFontSize(); &#125; else &#123; if (document.addEventListener) &#123; document.addEventListener(&quot;WeixinJSBridgeReady&quot;, handleFontSize, false); &#125; else if (document.attachEvent) &#123; &#x2F;&#x2F;IE浏览器，非W3C规范 document.attachEvent(&quot;onWeixinJSBridgeReady&quot;, handleFontSize); &#125; &#125; function handleFontSize() &#123; &#x2F;&#x2F; 设置网页字体为默认大小 WeixinJSBridge.invoke(&#39;setFontSizeCallback&#39;, &#123; &#39;fontSize&#39; : 0 &#125;); &#x2F;&#x2F; 重写设置网页字体大小的事件 WeixinJSBridge.on(&#39;menu:setfont&#39;, function() &#123; WeixinJSBridge.invoke(&#39;setFontSizeCallback&#39;, &#123; &#39;fontSize&#39; : 0 &#125;); &#125;); &#125;&#125;)();&#x2F;&#x2F;iOS：&#x2F;&#x2F; ios使用-webkit-text-size-adjust禁止调整字体大小body&#123;-webkit-text-size-adjust: 100%!important;&#125;复制代码 7、关于移动端样式兼容的问题 设置meta标签viewport属性，使其无视设备的真实分辨率，直接通过dpi，在物理尺寸和浏览器之间重设分辨率，从而达到能有统一的分辨率的效果。并且禁止掉用户缩放 12&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0, user-scalable&#x3D;no&quot; &#x2F;&gt;复制代码 使用rem进行屏幕适配，设置好root元素的font-size大小，然后在开发的时候，所有与像素有关的布局统一换成rem单位。 8、iOS下取消input在输入的时候英文首字母的默认大写12&lt;input type&#x3D;&quot;text&quot; autocapitalize&#x3D;&quot;none&quot;&gt;复制代码 9、禁止 iOS 识别长串数字为电话12&lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;复制代码 10、禁止ios和android用户选中文字12-webkit-user-select: none;复制代码 11、一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发只需要对不触发click事件的元素添加一行css代码即可： 12cursor: pointer;复制代码 调试工具1、Weinre远程调试工具简单的步骤： 1234567- 本地全局安装weinre , 命令行：npm install -g weinre- 在本地启动一个检测器：weinre --boundHost 1.2.3.4 （IP为本地IP地址）- 在浏览器访问此地址：http:&#x2F;&#x2F;1.2.3.4:8080- 把下面这一串东西，放在你需要调试的页面里：&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;1.2.3.4:8080&#x2F;target&#x2F;target-script-min.js#anonymous&quot;&gt;&lt;&#x2F;script&gt;- 点击链接打开：http:&#x2F;&#x2F;1.2.3.4:8080&#x2F;client&#x2F;#anonymous复制代码 2、vconsole 日志打印123import VConsole from &#39;vconsole&#39;var vConsole &#x3D; new VConsole();复制代码 3、fiddler抓包也需要支持https解决方案：fiddler需要安装信任证书，手机也需要安装信任证书，在浏览器里面打开 12http:&#x2F;&#x2F;1.2.3.4:8888 &#x2F;&#x2F; 本地IP地址+端口号复制代码 4、charles 手机端抓包，需要安装证书123手机浏览器输入：chls.pro&#x2F;ssl ，去下载证书。手机-设置-安全与隐私-更多安全下载-从sd卡安装证书 - 找到之前在浏览器下载的证书复制代码 vue相关问题1、vue 如何获取拉回数据后图片的高度？12345678910111213&lt;img :src&#x3D;&quot;userInfo.profilePicture&quot; alt class&#x3D;&quot;img-picture&quot; v-if&#x3D;&quot;userInfo.profilePicture&quot; ref&#x3D;&quot;myImg&quot; @load&#x3D;&quot;imageFn&quot;&gt; imageFn() &#123; console.log(this.$refs.myImg.offsetHeight); console.log(this.$refs.myImg.offsetWidth); &#125;,复制代码 2、vue中同一个dom节点，v-if与v-for不推荐同时使用，官方解答： 不推荐同时使用 v-if 和 v-for。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级 3、vue v-for 中更改item 属性值后，v-show不生效的问题123添加this.$forceUpdate();进行强制渲染，效果实现。因为数据层次太多，render函数没有自动更新，需手动强制刷新。复制代码 4、这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消12345678beforeRouteLeave(to, from, next) &#123; if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;votes&#x2F;subject&#39;) &#123; next(&#39;&#x2F;task-list&#39;); &#125; else &#123; next(); &#125;&#125;复制代码 5、element UI 自定义传参的解决方法这里的handleSelect默认绑定的参数是选中的那条数据。如果一个页面有好几个相同的组件，要想知道选的是哪个？ 1234567&lt;el-autocomplete v-model&#x3D;&quot;state4&quot; :fetch-suggestions&#x3D;&quot;querySearchAsync&quot; placeholder&#x3D;&quot;请输入内容&quot; @select&#x3D;&quot;handleSelect&quot;&gt;&lt;&#x2F;el-autocomplete&gt;复制代码 解决方案： 12345678&lt;el-autocomplete v-model&#x3D;&quot;state4&quot; :fetch-suggestions&#x3D;&quot;querySearchAsync&quot; placeholder&#x3D;&quot;请输入内容&quot; @select&#x3D;&quot;((item)&#x3D;&gt;&#123;handleSelect(item, index)&#125;)&quot; &#x2F;&#x2F; 写个闭包就可以了，index表示第几个组件&gt;&lt;&#x2F;el-autocomplete&gt;复制代码 6、element-UI 框架 el-input 触发不了 @key.enter事件12345&lt;el-input v-model&#x3D;&quot;form.loginName&quot; placeholder&#x3D;&quot;账号&quot; @keyup.enter&#x3D;&quot;doLogin&quot;&gt;&lt;&#x2F;el-input&gt;复制代码 解决方案：使用@key.center.native 1234&lt;el-input v-model&#x3D;&quot;form.loginName&quot;placeholder&#x3D;&quot;账号&quot; @keyup.enter.native&#x3D;&quot;doLogin&quot;&gt;&lt;&#x2F;el-input&gt; 转载自掘金快狗打车前端团队 https://juejin.im/post/5dfb3e73f265da33b12ea9d3#heading-26","tags":[]},{"title":"webpack最佳配置指北","date":"2020-01-03T09:12:02.278Z","path":"2020/01/03/webpack最佳配置指北/","text":"转载自掘金前端瓶子君https://juejin.im/post/5e0e1153e51d45414b74de65?utm_source=gold_browser_extension#heading-16webpack 最佳配置指北前言对于入门选手来讲，webpack 配置项很多很重，如何快速配置一个可用于线上环境的 webpack 就是一件值得思考的事情。其实熟悉 webpack 之后会发现很简单，基础的配置可以分为以下几个方面： entry 、 output 、 mode 、 resolve 、 module 、 optimization 、 plugin 、 source map 、 performance 等，本文就来重点分析下这些部分。 内附一张 webpack 零配置对比图片，关注公众号【前端瓶子君】回复【webpack】免费获取pdf文件。 一、配置入口 entry1、单入口和多入口将源文件加入到 webpack 构建流程，可以是单入口: 1234module.exports &#x3D; &#123; entry: &#96;.&#x2F;index.js&#96;,&#125;复制代码 构建包名称 [name]为 main ； 或多入口： 123456module.exports &#x3D; &#123; entry: &#123; &quot;index&quot;: &#96;.&#x2F;index.js&#96;, &#125;,&#125;复制代码 key:value 键值对的形式： key：构建包名称，即 [name] ，在这里为 index value：入口路径 入口决定 webapck 从哪个模块开始生成依赖关系图（构建包），每一个入口文件都对应着一个依赖关系图。 2. 动态配置入口文件动态打包所有子项目当构建项目包含多个子项目时，每次增加一个子系统都需要将入口文件写入 webpack 配置文件中，其实我们让webpack 动态获取入口文件，例如： 123456789&#x2F;&#x2F; 使用 glob 等工具使用若干通配符，运行时获得 entry 的条目module.exports &#x3D; &#123; entry: glob.sync(&#39;.&#x2F;project&#x2F;**&#x2F;index.js&#39;).reduce((acc, path) &#x3D;&gt; &#123; const entry &#x3D; path.replace(&#39;&#x2F;index.js&#39;, &#39;&#39;) acc[entry] &#x3D; path return acc &#125;, &#123;&#125;),&#125;复制代码 则会将所有匹配 ./project/**/index.js 的文件作为入口文件进行打包，如果你想要增加一个子项目，仅仅需要在 project 创建一个子项目目录，并创建一个 index.js 作为入口文件即可。 这种方式比较适合入口文件不集中且较多的场景。 动态打包某一子项目在构建多系统应用或组件库时，我们每次打包可能仅仅需要打包某一模块，此时，可以通过命令行的形式请求打印某一模块，例如： 12npm run build --project components复制代码 在打包的时候解析命令行参数： 12345&#x2F;&#x2F; 解析命令行参数const argv &#x3D; require(&#39;minimist&#39;)(process.argv.slice(2))&#x2F;&#x2F; 项目const project &#x3D; argv[&#39;project&#39;] || &#39;index&#39;复制代码 然后配置入口： 123456module.exports &#x3D; &#123; entry: &#123; &quot;index&quot;: &#96;.&#x2F;$&#123;project&#125;&#x2F;index.js&#96;, &#125; &#125;复制代码 相当于： 123456module.exports &#x3D; &#123; entry: &#123; &quot;index&quot;: &#96;.&#x2F;components&#x2F;index.js&#96;, &#125; &#125;复制代码 当然，你可以传入其它参数，也可以应用于多个地方，例如 resolve.alias 中。 二、配置出口 output用于告知 webpack 如何构建编译后的文件，可以自定义输出文件的位置和名称: 1234567891011121314151617181920module.exports &#x3D; &#123; output: &#123; &#x2F;&#x2F; path 必须为绝对路径 &#x2F;&#x2F; 输出文件路径 path: path.resolve(__dirname, &#39;..&#x2F;..&#x2F;dist&#x2F;build&#39;), &#x2F;&#x2F; 包名称 filename: &quot;[name].bundle.js&quot;, &#x2F;&#x2F; 或使用函数返回名(不常用) &#x2F;&#x2F; filename: (chunkData) &#x3D;&gt; &#123; &#x2F;&#x2F; return chunkData.chunk.name &#x3D;&#x3D;&#x3D; &#39;main&#39; ? &#39;[name].js&#39;: &#39;[name]&#x2F;[name].js&#39;; &#x2F;&#x2F; &#125;, &#x2F;&#x2F; 块名，公共块名(非入口) chunkFilename: &#39;[name].[chunkhash].bundle.js&#39;, &#x2F;&#x2F; 打包生成的 index.html 文件里面引用资源的前缀 &#x2F;&#x2F; 也为发布到线上资源的 URL 前缀 &#x2F;&#x2F; 使用的是相对路径，默认为 &#39;&#39; publicPath: &#39;&#x2F;&#39;, &#125;&#125;复制代码 在 webpack4 开发模式下，会默认启动 output.pathinfo ，它会输出一些额外的注释信息，对项目调试非常有用，尤其是使用 eval devtool 时。 filename ：[name] 为 entry 配置的 key，除此之外，还可以是 [id] （内部块 id ）、 [hash]、[contenthash] 等。 1. 浏览器缓存与 hash 值对于我们开发的每一个应用，浏览器都会对静态资源进行缓存，如果我们更新了静态资源，而没有更新静态资源名称（或路径），浏览器就可能因为缓存的问题获取不到更新的资源。在我们使用 webpack 进行打包的时候，webpack 提供了 hash 的概念，所以我们可以使用 hash 来打包。 在定义包名称（例如 chunkFilename 、 filename），我们一般会用到哈希值，不同的哈希值使用的场景不同： hashbuild-specific， 哈希值对应每一次构建（ Compilation ），即每次编译都不同，即使文件内容都没有改变，并且所有的资源都共享这一个哈希值，此时，浏览器缓存就没有用了，可以用在开发环境，生产环境不适用。 chunkhashchunk-specific， 哈希值对应于 webpack 每个入口点，每个入口都有自己的哈希值。如果在某一入口文件创建的关系依赖图上存在文件内容发生了变化，那么相应入口文件的 chunkhash 才会发生变化，适用于生产环境 contenthashcontent-specific，根据包内容计算出的哈希值，只要包内容不变，contenthash 就不变，适用于生产环境 但我们会发现，有时内容没有变更，打包时 [contenthash] 反而变更了的问题， webpack 也允许哈希的切片。如果你写 [hash:8] ，那么它会获取哈希值的前 8 位。 注意： 尽量在生产环境使用哈希 按需加载的块不受 filename 影响，受 chunkFilename 影响 使用 hash/chunkhash/contenthash 一般会配合 html-webpack-plugin （创建 html ，并捆绑相应的打包文件） 、clean-webpack-plugin （清除原有打包文件） 一起使用。 2. 打包成库当使用 webapck 构建一个可以被其它模块引用的库时： 1234567891011121314151617181920module.exports &#x3D; &#123; output: &#123; &#x2F;&#x2F; path 必须为绝对路径 &#x2F;&#x2F; 输出文件路径 path: path.resolve(__dirname, &#39;..&#x2F;..&#x2F;dist&#x2F;build&#39;), &#x2F;&#x2F; 包名称 filename: &quot;[name].bundle.js&quot;, &#x2F;&#x2F; 块名，公共块名(非入口) chunkFilename: &#39;[name].[chunkhash].bundle.js&#39;, &#x2F;&#x2F; 打包生成的 index.html 文件里面引用资源的前缀 &#x2F;&#x2F; 也为发布到线上资源的 URL 前缀 &#x2F;&#x2F; 使用的是相对路径，默认为 &#39;&#39; publicPath: &#39;&#x2F;&#39;, &#x2F;&#x2F; 一旦设置后该 bundle 将被处理为 library library: &#39;webpackNumbers&#39;, &#x2F;&#x2F; export 的 library 的规范，有支持 var, this, commonjs,commonjs2,amd,umd libraryTarget: &#39;umd&#39;, &#125;&#125;复制代码 三、配置模式 mode（webpack4）设置 mode ，可以让 webpack 自动调起相应的内置优化。 123456module.exports &#x3D; &#123; &#x2F;&#x2F; 可以是 none、development、production &#x2F;&#x2F; 默认为 production mode: &#39;production&#39;&#125;复制代码 或在命令行里配置： 12&quot;build:prod&quot;: &quot;webpack --config config&#x2F;webpack.prod.config.js --mode production&quot;复制代码 在设置了 mode 之后，webpack4 会同步配置 process.env.NODE_ENV 为 development 或 production 。 webpack4 最引人注目的主要是： 减小编译时间 打包时间减小了超过 60% 零配置 我们可以在没有任何配置文件的情况下将 webpack 用于各种项目 webpack4 支持零配置使用，这里的零配置就是指，mode 以及 entry （默认为 src/index.js）都可以通过入口文件指定，并且 webpack4 针对对不同的 mode 内置相应的优化策略。 1. production配置： 12345&#x2F;&#x2F; webpack.prod.config.jsmodule.exports &#x3D; &#123; mode: &#39;production&#39;,&#125;复制代码 相当于默认内置了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&#x2F;&#x2F; webpack.prod.config.jsmodule.exports &#x3D; &#123; performance: &#123; &#x2F;&#x2F; 性能设置,文件打包过大时，会报警告 hints: &#39;warning&#39; &#125;, output: &#123; &#x2F;&#x2F; 打包时，在包中不包含所属模块的信息的注释 pathinfo: false &#125;, optimization: &#123; &#x2F;&#x2F; 不使用可读的模块标识符进行调试 namedModules: false, &#x2F;&#x2F; 不使用可读的块标识符进行调试 namedChunks: false, &#x2F;&#x2F; 设置 process.env.NODE_ENV 为 production nodeEnv: &#39;production&#39;, &#x2F;&#x2F; 标记块是否是其它块的子集 &#x2F;&#x2F; 控制加载块的大小（加载较大块时，不加载其子集） flagIncludedChunks: true, &#x2F;&#x2F; 标记模块的加载顺序，使初始包更小 occurrenceOrder: true, &#x2F;&#x2F; 启用副作用 sideEffects: true, &#x2F;&#x2F; 确定每个模块的使用导出， &#x2F;&#x2F; 不会为未使用的导出生成导出 &#x2F;&#x2F; 最小化的消除死代码 &#x2F;&#x2F; optimization.usedExports 收集的信息将被其他优化或代码生成所使用 usedExports: true, &#x2F;&#x2F; 查找模块图中可以安全的连接到其它模块的片段 concatenateModules: true, &#x2F;&#x2F; SplitChunksPlugin 配置项 splitChunks: &#123; &#x2F;&#x2F; 默认 webpack4 只会对按需加载的代码做分割 chunks: &#39;async&#39;, &#x2F;&#x2F; 表示在压缩前的最小模块大小,默认值是30kb minSize: 30000, minRemainingSize: 0, &#x2F;&#x2F; 旨在与HTTP&#x2F;2和长期缓存一起使用 &#x2F;&#x2F; 它增加了请求数量以实现更好的缓存 &#x2F;&#x2F; 它还可以用于减小文件大小，以加快重建速度。 maxSize: 0, &#x2F;&#x2F; 分割一个模块之前必须共享的最小块数 minChunks: 1, &#x2F;&#x2F; 按需加载时的最大并行请求数 maxAsyncRequests: 6, &#x2F;&#x2F; 入口的最大并行请求数 maxInitialRequests: 4, &#x2F;&#x2F; 界定符 automaticNameDelimiter: &#39;~&#39;, &#x2F;&#x2F; 块名最大字符数 automaticNameMaxLength: 30, cacheGroups: &#123; &#x2F;&#x2F; 缓存组 vendors: &#123; test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125;, &#x2F;&#x2F; 当打包时，遇到错误编译，将不会把打包文件输出 &#x2F;&#x2F; 确保 webpack 不会输入任何错误的包 noEmitOnErrors: true, checkWasmTypes: true, &#x2F;&#x2F; 使用 optimization.minimizer || TerserPlugin 来最小化包 minimize: true, &#125;, plugins: [ &#x2F;&#x2F; 使用 terser 来优化 JavaScript new TerserPlugin(&#x2F;* ... *&#x2F;), &#x2F;&#x2F; 定义环境变量 new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) &#125;), &#x2F;&#x2F; 预编译所有模块到一个闭包中，提升代码在浏览器中的执行速度 new webpack.optimize.ModuleConcatenationPlugin(), &#x2F;&#x2F; 在编译出现错误时，使用 NoEmitOnErrorsPlugin 来跳过输出阶段。 &#x2F;&#x2F; 这样可以确保输出资源不会包含错误 new webpack.NoEmitOnErrorsPlugin() ]&#125;复制代码 2. development配置： 12345&#x2F;&#x2F; webpack.dev.config.jsmodule.exports &#x3D; &#123; mode: &#39;development&#39;,&#125;复制代码 相当于默认内置了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#x2F;&#x2F; webpack.dev.config.jsmodule.exports &#x3D; &#123; devtool: &#39;eval&#39;, cache: true, performance: &#123; &#x2F;&#x2F; 性能设置,文件打包过大时，不报错和警告，只做提示 hints: false &#125;, output: &#123; &#x2F;&#x2F; 打包时，在包中包含所属模块的信息的注释 pathinfo: true &#125;, optimization: &#123; &#x2F;&#x2F; 使用可读的模块标识符进行调试 namedModules: true, &#x2F;&#x2F; 使用可读的块标识符进行调试 namedChunks: true, &#x2F;&#x2F; 设置 process.env.NODE_ENV 为 development nodeEnv: &#39;development&#39;, &#x2F;&#x2F; 不标记块是否是其它块的子集 flagIncludedChunks: false, &#x2F;&#x2F; 不标记模块的加载顺序 occurrenceOrder: false, &#x2F;&#x2F; 不启用副作用 sideEffects: false, usedExports: false, concatenateModules: false, splitChunks: &#123; hidePathInfo: false, minSize: 10000, maxAsyncRequests: Infinity, maxInitialRequests: Infinity, &#125;, &#x2F;&#x2F; 当打包时，遇到错误编译，仍把打包文件输出 noEmitOnErrors: false, checkWasmTypes: false, &#x2F;&#x2F; 不使用 optimization.minimizer || TerserPlugin 来最小化包 minimize: false, removeAvailableModules: false &#125;, plugins: [ &#x2F;&#x2F; 当启用 HMR 时，使用该插件会显示模块的相对路径 &#x2F;&#x2F; 建议用于开发环境 new webpack.NamedModulesPlugin(), &#x2F;&#x2F; webpack 内部维护了一个自增的 id，每个 chunk 都有一个 id。 &#x2F;&#x2F; 所以当增加 entry 或者其他类型 chunk 的时候，id 就会变化， &#x2F;&#x2F; 导致内容没有变化的 chunk 的 id 也发生了变化 &#x2F;&#x2F; NamedChunksPlugin 将内部 chunk id 映射成一个字符串标识符（模块的相对路径） &#x2F;&#x2F; 这样 chunk id 就稳定了下来 new webpack.NamedChunksPlugin(), &#x2F;&#x2F; 定义环境变量 new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;), ]&#125;复制代码 3. none不进行任何默认优化选项。 配置： 12345&#x2F;&#x2F; webpack.com.config.jsmodule.exports &#x3D; &#123; mode: &#39;none&#39;,&#125;复制代码 相当于默认内置了： 123456789101112131415161718192021222324252627282930&#x2F;&#x2F; webpack.com.config.jsmodule.exports &#x3D; &#123; performance: &#123; &#x2F;&#x2F; 性能设置,文件打包过大时，不报错和警告，只做提示 hints: false &#125;, optimization: &#123; &#x2F;&#x2F; 不标记块是否是其它块的子集 flagIncludedChunks: false, &#x2F;&#x2F; 不标记模块的加载顺序 occurrenceOrder: false, &#x2F;&#x2F; 不启用副作用 sideEffects: false, usedExports: false, concatenateModules: false, splitChunks: &#123; hidePathInfo: false, minSize: 10000, maxAsyncRequests: Infinity, maxInitialRequests: Infinity, &#125;, &#x2F;&#x2F; 当打包时，遇到错误编译，仍把打包文件输出 noEmitOnErrors: false, checkWasmTypes: false, &#x2F;&#x2F; 不使用 optimization.minimizer || TerserPlugin 来最小化包 minimize: false, &#125;, plugins: []&#125;复制代码 4. production、 development、none 总结 img img img 注意：关注公众号【前端瓶子君】回复【webpack】免费获取pdf原文件。 production 模式下给你更好的用户体验： 较小的输出包体积 浏览器中更快的代码执行速度 忽略开发中的代码 不公开源代码或文件路径 易于使用的输出资产 development 模式会给予你最好的开发体验： 浏览器调试工具 快速增量编译可加快开发周期 运行时提供有用的错误消息 尽管 webpack4 在尽力让零配置做到更多，但仍然是有限度的，大多数情况下还是需要一个配置文件。我们可以在项目的初期使用零配置，在后期业务复杂的时候再配置。 5. 环境变量 process.env.NODE_ENV第三方框架或库，以及我们的业务代码，都会针对不同的环境配置，执行不同的逻辑代码，例如： 我们可以通过以下方式定义环境变量： 方法一：webpack4 中 mode: ‘production’ 已经默认配置了 process.env.NODE_ENV = ‘production’ ，所以 webapck4 可以不定义 尽管 webpack4 中定义 mode 会自动配置 process.env.NODE_ENV ，那么我们就不需要手动配置环境变量了吗？ 其实不然，mode 只可以定义成 development 或 production ，而在项目中，我们不仅仅只有开发或生产环境，很多情况下需要配置不同的环境（例如测试环境），此时我们就需要手动配置其它环境变量（例如测试环境，就需要定义 process.env.NODE_ENV 为 &#39;test&#39; ），你可以采取以下方式： 方法二：webpack.DefinePlugin 12345&#x2F;&#x2F; webpack编译过程中设置全局变量process.envnew webpack.DefinePlugin(&#123; &#39;process.env&#39;: require(&#39;..&#x2F;config&#x2F;dev.env.js&#39;)&#125;复制代码 config/prod.env.js ： 12345module.exports &#x3D;&#123; &#x2F;&#x2F; 或 &#39;&quot;production&quot;&#39; ，环境变量的值需要是一个由双引号包裹的字符串 NODE_ENV: JSON.stringify(&#39;production&#39;) &#125;复制代码 方法三：webpack 命令时， NODE_ENV=development 在 window 中配置 NODE_ENV=production 可能会卡住，所以使用 cross-env： 12cross-env NODE_ENV&#x3D;production webpack --config webpack.config.prod.js复制代码 方法四：使用 new webpack.EnvironmentPlugin([&#39;NODE_ENV&#39;]) EnvironmentPlugin 是一个通过 webpack.DefinePlugin 来设置 process.env 环境变量的快捷方式。 1234new webpack.EnvironmentPlugin(&#123; NODE_ENV: &#39;production&#39;,&#125;);复制代码 注意：上面其实是给 NODE_ENV 设置一个默认值 &#39;production&#39; ，如果其它地方有定义 process.env.NODE_ENV ，则该默认值无效。 四、配置解析策略 resolve自定义寻找依赖模块时的策略（例如 import _ from &#39;lodash&#39;）: 123456789101112131415161718192021module.exports &#x3D; &#123; resolve: &#123; &#x2F;&#x2F; 设置模块导入规则，import&#x2F;require时会直接在这些目录找文件 &#x2F;&#x2F; 可以指明存放第三方模块的绝对路径，以减少寻找， &#x2F;&#x2F; 默认 node_modules modules: [path.resolve(&#96;$&#123;project&#125;&#x2F;components&#96;), &#39;node_modules&#39;], &#x2F;&#x2F; import导入时省略后缀 &#x2F;&#x2F; 注意：尽可能的减少后缀尝试的可能性 extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.react.js&#39;, &#39;.css&#39;, &#39;.json&#39;], &#x2F;&#x2F; import导入时别名，减少耗时的递归解析操作 alias: &#123; &#39;@components&#39;: path.resolve(&#96;$&#123;project&#125;&#x2F;components&#96;), &#39;@style&#39;: path.resolve(&#39;asset&#x2F;style&#39;), &#125;, &#x2F;&#x2F; 很多第三方库会针对不同的环境提供几份代码 &#x2F;&#x2F; webpack 会根据 mainFields 的配置去决定优先采用那份代码 &#x2F;&#x2F; 它会根据 webpack 配置中指定的 target 不同，默认值也会有所不同 mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;main&#39;], &#125;,&#125;复制代码 五、配置解析和转换文件的策略 module决定如何处理项目中不同类型的模块，通常是配置 module.rules 里的 Loader: 123456789101112131415161718192021222324252627282930module.exports &#x3D; &#123; module: &#123; &#x2F;&#x2F; 指明 webpack 不去解析某些内容，该方式有助于提升 webpack 的构建性能 noParse: &#x2F;jquery&#x2F;, rules: [ &#123; &#x2F;&#x2F; 这里编译 js、jsx &#x2F;&#x2F; 注意：如果项目源码中没有 jsx 文件就不要写 &#x2F;\\.jsx?$&#x2F;，提升正则表达式性能 test: &#x2F;\\.(js|jsx)$&#x2F;, &#x2F;&#x2F; 指定要用什么 loader 及其相关 loader 配置 use: &#123; loader: &quot;babel-loader&quot;, options: &#123; &#x2F;&#x2F; babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 &#x2F;&#x2F; 使用 cacheDirectory 选项将 babel-loader 的速度提高2倍 cacheDirectory: true, &#x2F;&#x2F; Save disk space when time isn&#39;t as important cacheCompression: true, compact: true, &#125; &#125;, &#x2F;&#x2F; 排除 node_modules 目录下的文件 &#x2F;&#x2F; node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 exclude: &#x2F;node_modules&#x2F; &#x2F;&#x2F; 也可以配置 include：需要引入的文件 &#125; ] &#125;&#125;复制代码 1. noParse指明 webpack 不去解析某些内容，该方式有助于提升 webpack 的构建性能。 2. rules常见的 loader 有： babel-loader：解析 .js 和 .jsx 文件 12345678910111213141516171819202122232425262728&#x2F;&#x2F; 配置 .babelrc&#123; &quot;presets&quot;: [ [ &quot;@babel&#x2F;preset-env&quot;, ], &quot;@babel&#x2F;preset-react&quot; ], &quot;plugins&quot;: [ [ &quot;@babel&#x2F;plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot;: true &#125; ], [ &quot;@babel&#x2F;plugin-transform-runtime&quot;, &#123; &quot;absoluteRuntime&quot;: false, &quot;corejs&quot;: false, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125; ], ]&#125;复制代码 tsx-loader：处理 ts 文件 less-loader：处理 less 文件，并将其编译为 css sass-loader：处理 sass、scss 文件，并将其编译为 css postcss-loader： 12345&#x2F;&#x2F; postcss.config.jsmodule.exports &#x3D; &#123; &#x2F;&#x2F; 解析CSS文件并且添加浏览器前缀到 CSS 内容里 plugins: [require(&#39;autoprefixer&#39;)],&#125;;复制代码 css-loader：处理 css 文件 style-loader：将 css 注入到 DOM file-loader：将文件上的import / require 解析为 url，并将该文件输出到输出目录中 url-loader：用于将文件转换成 base64 uri 的 webpack 加载程序 html-loader：将 HTML 导出为字符串， 当编译器要求时，将 HTML 最小化 更多 loaders 可查看 LOADERS 。 六、配置优化 optimization（webpack4）webapck4 会根据你所选择的 mode 进行优化，你可以手动配置，它将会覆盖自动优化，详细配置请见 Optimization 。 主要涉及两方面的优化： 最小化包 拆包 1. 最小化包 使用 optimization.removeAvailableModules 删除已可用模块 使用 optimization.removeEmptyChunks 删除空模块 使用 optimization.occurrenceOrder 标记模块的加载顺序，使初始包更小 使用 optimization.providedExports 、 optimization.usedExports 、concatenateModules 、optimization.sideEffects 删除死代码 使用 optimization.splitChunks 提取公共包 使用 optimization.minimizer || TerserPlugin 来最小化包 2. 拆包当包过大时，如果我们更新一小部分的包内容，那么整个包都需要重新加载，如果我们把这个包拆分，那么我们仅仅需要重新加载发生内容变更的包，而不是所有包，有效的利用了缓存。 拆分 node_modules很多情况下，我们不需要手动拆分包，可以使用 optimization.splitChunks ： 123456789101112131415const path &#x3D; require(&#39;path&#39;);module.exports &#x3D; &#123; entry: path.resolve(__dirname, &#39;src&#x2F;index.js&#39;), output: &#123; path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;[name].[contenthash].js&#39;, &#125;, optimization: &#123; splitChunks: &#123; &#x2F;&#x2F; 对所有的包进行拆分 chunks: &#39;all&#39;, &#125;, &#125;,&#125;;复制代码 我们不必制定拆包策略，chunks: all 会自动将 node_modules 中的所有内容放入一个名为 vendors〜main.js 的文件中。 拆分业务代码12345678910111213module.exports &#x3D; &#123; entry: &#123; main: path.resolve(__dirname, &#39;src&#x2F;index.js&#39;), ProductList: path.resolve(__dirname, &#39;src&#x2F;ProductList&#x2F;ProductList.js&#39;), ProductPage: path.resolve(__dirname, &#39;src&#x2F;ProductPage&#x2F;ProductPage.js&#39;), Icon: path.resolve(__dirname, &#39;src&#x2F;Icon&#x2F;Icon.js&#39;), &#125;, output: &#123; path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;[name].[contenthash:8].js&#39;, &#125;,&#125;;复制代码 采用多入口的方式，当有业务代码更新时，更新相应的包即可 拆分第三方库12345678910111213141516171819202122232425262728293031const path &#x3D; require(&#39;path&#39;);const webpack &#x3D; require(&#39;webpack&#39;);module.exports &#x3D; &#123; entry: path.resolve(__dirname, &#39;src&#x2F;index.js&#39;), output: &#123; path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;[name].[contenthash].js&#39;, &#125;, optimization: &#123; runtimeChunk: &#39;single&#39;, splitChunks: &#123; chunks: &#39;all&#39;, maxInitialRequests: Infinity, minSize: 0, cacheGroups: &#123; vendor: &#123; test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;, name(module) &#123; &#x2F;&#x2F; 获取第三方包名 const packageName &#x3D; module.context.match(&#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;](.*?)([\\\\&#x2F;]|$)&#x2F;)[1]; &#x2F;&#x2F; npm 软件包名称是 URL 安全的，但是某些服务器不喜欢@符号 return &#96;npm.$&#123;packageName.replace(&#39;@&#39;, &#39;&#39;)&#125;&#96;; &#125;, &#125;, &#125;, &#125;, &#125;,&#125;;复制代码 当第三方包更新时，仅更新相应的包即可。 注意，当包太多时，浏览器会发起更多的请求，并且当文件过小时，对代码压缩也有影响。 动态加载现在我们已经对包拆分的很彻底了，但以上的拆分仅仅是对浏览器缓存方面的优化，减小首屏加载时间，实际上我们也可以使用按需加载的方式来进一步拆分，减小首屏加载时间： 12345678910111213141516171819import React, &#123; useState, useEffect &#125; from &#39;react&#39;;import &#39;.&#x2F;index.scss&#39;function Main() &#123; const [NeighborPage, setNeighborPage] &#x3D; useState(null) useEffect(() &#x3D;&gt; &#123; import(&#39;..&#x2F;neighbor&#39;).then((&#123; default: component &#125;) &#x3D;&gt; &#123; setNeighborPage(React.createElement(component)) &#125;); &#125;, []) return NeighborPage ? NeighborPage : &lt;div&gt;Loading...&lt;&#x2F;div&gt;;&#125;export default Main复制代码 七、配置 plugin配置 Plugin 去处理及优化其它的需求， 123456789101112131415161718192021222324module.exports &#x3D; &#123; plugins: [ &#x2F;&#x2F; 优化 require new webpack.ContextReplacementPlugin(&#x2F;moment[\\&#x2F;\\\\]locale$&#x2F;, &#x2F;en|zh&#x2F;), &#x2F;&#x2F; 用于提升构建速度 createHappyPlugin(&#39;happy-babel&#39;, [&#123; loader: &#39;babel-loader&#39;, options: &#123; presets: [&#39;@babel&#x2F;preset-env&#39;, &quot;@babel&#x2F;preset-react&quot;], plugins: [ [&#39;@babel&#x2F;plugin-proposal-class-properties&#39;, &#123; loose: true &#125;] ], &#x2F;&#x2F; babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 cacheDirectory: true, &#x2F;&#x2F; Save disk space when time isn&#39;t as important cacheCompression: true, compact: true, &#125; &#125;]) ]&#125;复制代码 常用 plugins： html-webpack-plugin：生成 html 文件，并将包添加到 html 中 webpack-parallel-uglify-plugin：压缩 js（多进程并行处理压缩） happypack：多线程loader，用于提升构建速度 hard-source-webpack-plugin：为模块提供中间缓存步骤，显著提高打包速度 webpack-merge：合并 webpack 配置 mini-css-extract-plugin：抽离 css optimize-css-assets-webpack-plugin：压缩 css add-asset-html-webpack-plugin：将 JavaScript 或 CSS 资产添加到 html-webpack-plugin 生成的 HTML 中 更多插件可见：plugins 八、配置devtool：source map配置 webpack 如何生成 Source Map，用来增强调试过程。不同的值会明显影响到构建(build)和重新构建(rebuild)的速度： 生产环境：默认为 null ，一般不设置（ none ）或 nosources-source-map 开发环境：默认为 eval ，一般设置为 eval 、 cheap-eval-source-map 、cheap-module-eval-source-map 策略为： 使用 cheap 模式可以大幅提高 souremap 生成的效率。 没有列信息（会映射到转换后的代码，而不是映射到原始代码），通常我们调试并不关心列信息，而且就算 source map 没有列，有些浏览器引擎（例如 v8） 也会给出列信息。 使用 eval 方式可大幅提高持续构建效率。参考官方文档提供的速度对比表格可以看到 eval 模式的编译速度很快。 使用 module 可支持 babel 这种预编译工具（在 webpack 里做为 loader 使用）。 如果默认的 webpack minimizer 已经被重定义(例如 terser-webpack-plugin )，你必须提供 sourceMap：true 选项来启用 source map 支持。 更多可查看：devtool 九、配置性能 performance当打包是出现超过特定文件限制的资产和入口点，performance 控制 webpack 如何通知： 1234567891011module.exports &#x3D; &#123; &#x2F;&#x2F; 配置如何显示性能提示 performance: &#123; &#x2F;&#x2F; 可选 warning、error、false &#x2F;&#x2F; false：性能设置,文件打包过大时，不报错和警告，只做提示 &#x2F;&#x2F; warning：显示警告，建议用在开发环境 &#x2F;&#x2F; error：显示错误，建议用在生产环境，防止部署太大的生产包，从而影响网页性能 hints: false &#125;&#125;复制代码 十、配置其它1. watch 与 watchOptionswatch监视文件更新，并在文件更新时重新编译： 12345module.export &#x3D; &#123; &#x2F;&#x2F; 启用监听模式 watch: true,&#125;复制代码 在 webpack-dev-server 和 webpack-dev-middleware 中，默认启用了监视模式。 或者我们可以在命令行里启动监听（ --watch ）： 12webpack --watch --config webpack.config.dev.js复制代码 watchOptions123456789101112131415module.export &#x3D; &#123; watch: true, &#x2F;&#x2F; 自定义监视模式 watchOptions: &#123; &#x2F;&#x2F; 排除监听 ignored: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 监听到变化发生后，延迟 300ms（默认） 再去执行动作， &#x2F;&#x2F; 防止文件更新太快导致重新编译频率太高 aggregateTimeout: 300, &#x2F;&#x2F; 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的 &#x2F;&#x2F; 默认 1000ms 询问一次 poll: 1000 &#125;&#125;复制代码 2. externals排除打包时的依赖项，不纳入打包范围内，例如你项目中使用了 jquery ，并且你在 html 中引入了它，那么在打包时就不需要再把它打包进去： 123456&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.0.js&quot; integrity&#x3D;&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk&#x3D;&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;复制代码 配置： 1234567module.exports &#x3D; &#123; &#x2F;&#x2F; 打包时排除 jquery 模块 externals: &#123; jquery: &#39;jQuery&#39; &#125;&#125;;复制代码 3.target构建目标，用于为 webpack 指定一个环境： 12345module.exports &#x3D; &#123; &#x2F;&#x2F; 编译为类浏览器环境里可用（默认） target: &#39;web&#39;&#125;;复制代码 4. cache缓存生成的 webpack 模块和块以提高构建速度。在开发模式中，缓存设置为 type: &#39;memory&#39; ，在生产模式中禁用。cache: true 是 cache: {type: &#39;memory&#39;} 的别名。要禁用缓存传递 false ： 1234module.exports &#x3D; &#123; cache: false&#125;复制代码 在内存中，缓存仅在监视模式下有用，并且我们假设你在开发中使用监视模式。 在不进行缓存的情况下，内存占用空间较小。 5. name配置的名称，用于加载多个配置： 123module.exports &#x3D; &#123; name: &#39;admin-app&#39;&#125;;","tags":[]},{"title":"构建大型Vue-js项目的10条建议","date":"2019-12-30T02:09:20.605Z","path":"2019/12/30/构建大型Vue-js项目的10条建议/","text":"转载自掘金KaysonLihttps://juejin.im/post/5dcbd5f66fb9a06061527cb9#heading-2构建大型 Vue.js 项目的10条建议下面是我在开发大型 Vue 项目时的最佳实践。这些技巧将帮助你开发更高效、更易于维护和共享的代码。 今年做自由职业的时候，我有机会开发了一些大型 Vue 应用程序。我所说的这些项目，Vuex store 超过十个，包含大量的组件（有时候几百个）和视图页面。对我来说这是个很有益的经验，因为我发现了很多有意思的模式，可以让代码拥有更好的伸缩性。我还必须修正一些导致著名的意大利面条式代码困境的错误实践。 因此，今天我将与你分享10个最佳实践，如果你正在处理大型代码库，我建议你参考这些方法。 1. 使用 slot, 让组件更强大，也更容易理解最近我写了篇关于 Vue.js slot 的文章，它强调了 slot 如何使组件更易于重用和维护，以及为什么应该使用它们。 🧐 但是这与 Vue.js 大型项目有什么关系呢？一张图片通常胜过千言万语，所以我要给你描绘一幅关于我第一次后悔没有使用它们的画面。 有一天，我要创建一个 popup。乍一看并没有什么复杂的东西，只是包含了一个标题，一个描述和一些按钮。所以我所做的就是把一切配置一股脑当做 props 传进去。最终我定义了三个 prop，用于自定义组件，当用户单击按钮时将发送一个事件。So easy ! 但是，随着项目的发展，团队要求我们在其中展示更多其他的新内容：表单字段、不同的按钮(取决于它显示在哪个页面上)、卡片、页脚，以及列表。我以为，如果继续使用 prop 来迭代这个组件也没啥问题。但是我滴个神哪，我是大错特错！组件很快变得非常复杂，难以理解，因为它包含了无数的子组件，用了太多的 prop，并发送了一堆的事件。我开始体验到了可怕的情况，当你做出一点改动，其他页面的某个地方就会崩溃！我仿佛造了一个 Frankenstein 怪人，而不是一个可维护的组件!🤖 然而，如果我从一开始就依赖 slot，情况可能会好多了。最后我重构了所有东西，得到了这个小组件：更容易维护，理解起来更快，更好扩展！ 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class&#x3D;&quot;c-base-popup&quot;&gt; &lt;div v-if&#x3D;&quot;$slot.header&quot; class&#x3D;&quot;c-base-popup__header&quot;&gt; &lt;slot name&#x3D;&quot;header&quot;&gt; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;$slot.subheader&quot; class&#x3D;&quot;c-base-popup__subheader&quot;&gt; &lt;slot name&#x3D;&quot;subheader&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;c-base-popup__body&quot;&gt; &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h1&gt; &lt;p v-if&#x3D;&quot;description&quot;&gt;&#123;&#123; description &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;$slot.actions&quot; class&#x3D;&quot;c-base-popup__actions&quot;&gt; &lt;slot name&#x3D;&quot;actions&quot;&gt; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;$slot.footer&quot; class&#x3D;&quot;c-base-popup__footer&quot;&gt; &lt;slot name&#x3D;&quot;footer&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: &#123; description: &#123; type: String, default: null &#125;, title: &#123; type: String, required: true &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 我的观点是，从经验来看，那些知道何时使用 slot 的开发人员所构建的项目确实会对其未来的可维护性产生很大的影响。由于发送的事件更少，代码更容易理解，而且提供了更大的灵活性，可以在其中显示任何组件。 ️ 敲黑板：根据经验，当你开始在父组件中复制子组件的 prop 时，你就应该考虑使用 slot 了。 2. 合理组织 Vuex Store通常，Vue.js 新手开始了解Vuex，因为他们刚好碰到了这两个问题： 组件树结构中相隔太远的组件之间访问数据 组件销毁后需要持久化数据 这个时候他们就会创建第一个 Vuex store，学习模块并开始在应用程序中组织它们。 问题在于，创建模块时没有单一的模式可以遵循。然而，我强烈建议你仔细考虑如何组织它们。据我所见，大多数开发人员更喜欢根据功能来组织它们。例如: Auth. Blog. Inbox. Settings. 就我来说，我发现根据从 API 获取的数据模型来组织它们更容易理解。例如: Users Teams Messages Widgets Articles 如何选择取决于你自己。唯一需要记住的是，从长远来看，一个组织良好的 Vuex store 会造就一个更高效的团队。它还将使新人在加入团队时更容易将他们的想法围绕在你的代码基础上。 3. 使用 action 发起 API 调用和提交数据我的大部分 API 调用（如果不是全部）是在Vuex action 里面完成的。你可能会问：为什么要这么做？ 🤨 🤷‍♀️ 简单来说，它们中的大多数获取的数据需要提交到 store里去。另外，它们还提供了一层封装和可重用性，我很喜欢用。还有一些原因如下： 如果我需要在两个地方（假设是博客页面和首页）获取文章的第一页，我只需要用正确的参数调用合适的 dispatcher 就行了。除了 dispatcher 调用，无需重复代码就可以完成数据的获取，commit 到 store 和返回。 如果我需要写一些避免重复获取第一页的逻辑，我就可以在一个地方完成。这样做除了会减轻服务器负载，还会增强我对代码的信心。 我可以跟踪这些操作中的大多数 Mixpanel（一个网站用户行为分析工具） 事件，这使得分析代码非常容易维护。我确实有一些应用程序，其中所有的 Mixpanel 调用都是只在 action 中完成的。我不需要了解哪些数据被跟踪，哪些没有，以及什么时候发送这些信息。以这种工作方式的乐趣简直无法言说。 4. 用 mapState，mapGetters，mapMutations 和 mapActions 简化代码通常不需要创建多个计算属性或方法，只需在组件内部访问 state/getters 或者调用 actions/mutations 。使用mapState，mapGetters，mapMutations 和 mapActions 可以帮助你简化代码，把来自 store 模块的数据分组到一起，让代码更容易理解。 123456789101112131415161718192021222324&#x2F;&#x2F; NPMimport &#123; mapState, mapGetters, mapActions, mapMutations &#125; from &quot;vuex&quot;;export default &#123; computed: &#123; &#x2F;&#x2F; Accessing root properties ...mapState(&quot;my_module&quot;, [&quot;property&quot;]), &#x2F;&#x2F; Accessing getters ...mapGetters(&quot;my_module&quot;, [&quot;property&quot;]), &#x2F;&#x2F; Accessing non-root properties ...mapState(&quot;my_module&quot;, &#123; property: state &#x3D;&gt; state.object.nested.property &#125;) &#125;, methods: &#123; &#x2F;&#x2F; Accessing actions ...mapActions(&quot;my_module&quot;, [&quot;myAction&quot;]), &#x2F;&#x2F; Accessing mutations ...mapMutations(&quot;my_module&quot;, [&quot;myMutation&quot;]) &#125;&#125;;复制代码 有关以上工具方法的所有信息都在 Vuex 官方文档。🤩 5. 使用 API 工厂我通常喜欢写一个this.$api 助手，以便在任何地方调用，获取后台 API 资源。在我的项目根目录有一个api 文件夹，包含了所有相关的类。如下所示（仅部分）： 123456api├── auth.js├── notifications.js└── teams.js复制代码 每个文件都将其类别下的所有 API 资源分组。下面是我在 Nuxt 应用中使用插件初始化这个模式的方法（在标准的 Vue 应用中的过程也类似）。 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; PROJECT: APIimport Auth from &quot;@&#x2F;api&#x2F;auth&quot;;import Teams from &quot;@&#x2F;api&#x2F;teams&quot;;import Notifications from &quot;@&#x2F;api&#x2F;notifications&quot;;export default (context, inject) &#x3D;&gt; &#123; if (process.client) &#123; const token &#x3D; localStorage.getItem(&quot;token&quot;); &#x2F;&#x2F; Set token when defined if (token) &#123; context.$axios.setToken(token, &quot;Bearer&quot;); &#125; &#125; &#x2F;&#x2F; Initialize API repositories const repositories &#x3D; &#123; auth: Auth(context.$axios), teams: Teams(context.$axios), notifications: Notifications(context.$axios) &#125;; inject(&quot;api&quot;, repositories);&#125;;复制代码export default $axios &#x3D;&gt; (&#123; forgotPassword(email) &#123; return $axios.$post(&quot;&#x2F;auth&#x2F;password&#x2F;forgot&quot;, &#123; email &#125;); &#125;, login(email, password) &#123; return $axios.$post(&quot;&#x2F;auth&#x2F;login&quot;, &#123; email, password &#125;); &#125;, logout() &#123; return $axios.$get(&quot;&#x2F;auth&#x2F;logout&quot;); &#125;, register(payload) &#123; return $axios.$post(&quot;&#x2F;auth&#x2F;register&quot;, payload); &#125;&#125;);复制代码 现在，我可以简单地在我的组件或 Vuex action 里像这样调用它们： 12345678910111213export default &#123; methods: &#123; onSubmit() &#123; try &#123; this.$api.auth.login(this.email, this.password); &#125; catch (error) &#123; console.error(error); &#125; &#125; &#125;&#125;;复制代码 6. 使用 $config 访问环境变量（在模板里特别有用）你的项目可能在一些文件中定义了一些全局配置变量： 12345config├── development.json└── production.json复制代码 我喜欢通过 this.$config 助手快速访问它们，特别是在模板里。像往常一样，扩展 Vue 对象非常容易： 1234567891011121314&#x2F;&#x2F; NPMimport Vue from &quot;vue&quot;;&#x2F;&#x2F; PROJECT: COMMONSimport development from &quot;@&#x2F;config&#x2F;development.json&quot;;import production from &quot;@&#x2F;config&#x2F;production.json&quot;;if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot;) &#123; Vue.prototype.$config &#x3D; Object.freeze(production);&#125; else &#123; Vue.prototype.$config &#x3D; Object.freeze(development);&#125;复制代码 7. 按照某个约定来给代码提交命名随着项目的增长，你可能需要定期浏览组件的历史记录。如果你的团队没有遵循相同的约定来命名他们的提交，那么理解每个提交将会变得更加困难。 我一直推荐使用 Angular 提交信息指南。我在每个项目中都遵循它，在很多情况下，其他团队成员很快就会发现遵循它带来的好处。 遵循这些指导原则可以得到更具可读性的信息，这使得在查看项目历史记录时更容易跟踪提交。简而言之，它是这样工作的： 1234567git commit -am &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;# 举例git commit -am &quot;docs(changelog): update changelog to beta.5&quot;git commit -am &quot;fix(release): need to depend on latest rxjs and zone.js&quot;复制代码 看下他们的 README 文件 了解更多了解更多关于它和相关约定。 8. 项目上线后固定 package 版本我知道，所有 package 都应该遵循语义化版本规则。但现实情况是，有些根本没有遵守。 为了避免因为某个依赖项破坏了整个项目而不得不在半夜醒来，锁定所有 package 版本可以让你的早晨工作压力更小。 它的意思很简单：避免使用带 ^ 前缀的版本号： 1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;my project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: &#123; &quot;axios&quot;: &quot;0.19.0&quot;, &quot;imagemin-mozjpeg&quot;: &quot;8.0.0&quot;, &quot;imagemin-pngquant&quot;: &quot;8.0.0&quot;, &quot;imagemin-svgo&quot;: &quot;7.0.0&quot;, &quot;nuxt&quot;: &quot;2.8.1&quot;, &#125;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;9.6.1&quot;, &quot;babel-eslint&quot;: &quot;10.0.2&quot;, &quot;eslint&quot;: &quot;6.1.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;4.0.1&quot;, &quot;eslint-loader&quot;: &quot;2.2.1&quot;, &quot;eslint-plugin-vue&quot;: &quot;5.2.3&quot; &#125;&#125;复制代码 9. 在显示大量数据时使用 Vue Virtual Scroller当你需要在某个页面中显示大量的行，或者需要循环大量的数据时，你可能已经注意到页面可能会很快变得非常慢。要解决这个问题，你可以使用vue-virtual-scoller。 123npm install vue-virtual-scroller复制代码 它将只渲染列表中可见的项，并重用组件和 dom 元素，效率高，性能好。它真的很容易使用，如丝般顺滑！✨ 123456789101112131415&lt;template&gt; &lt;RecycleScroller class&#x3D;&quot;scroller&quot; :items&#x3D;&quot;list&quot; :item-size&#x3D;&quot;32&quot; key-field&#x3D;&quot;id&quot; v-slot&#x3D;&quot;&#123; item &#125;&quot; &gt; &lt;div class&#x3D;&quot;user&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;RecycleScroller&gt;&lt;&#x2F;template&gt;复制代码 10. 跟踪第三方包的大小当很多人在同一个项目中工作时，如果没人关注安装包的数量，那么很快就会越来越多。为了避免应用程序变慢(特别是在移动网络变慢的情况下)，我在 VS Code 中使用了 import cost 插件。这样，我就可以从我的编辑器中看到导入的模块库有多大，并且可以在它变得太大时检查出问题。 例如，在最近的一个项目中，整个 lodash 库被导入(大约有24kB的gzipped)。结果只使用了 cloneDeep 方法。通过 import cost 插件定位到这个问题，我们是这样解决的： 1234npm remove lodashnpm install lodash.clonedeep复制代码 cloneDeep 函数可以在需要的地方引入： 123import cloneDeep from &quot;lodash.clonedeep&quot;;复制代码 ️ 要进一步优化，你可以使用 Webpack Bundle Analyzer ，用交互式的可缩放地图可视化文件大小。","tags":[]},{"title":"前端性能优化(一)","date":"2019-12-29T01:46:18.206Z","path":"2019/12/29/前端性能优化(一)/","text":"前端性能优化（一）在讨论具体如何优化之前，先思考一个经典问题，从输入 URL 到页面加载完成到底发生了什么？ URL 经过 DNS 解析为 IP 地址，然后与 IP 地址进行 TCP 连接，随后发出 HTTP 请求，服务器处理完请求之后将内容通过 HTTP 发送给客户端，拿到数据后浏览器就开始渲染流程。简单的说分为以下几个步骤：DNS 解析，TCP 连接，HTTP 请求，HTTP响应，浏览器解析并渲染。 这个问题解决之后，就可以从各个层面分析如何做性能优化了。 DNS 预解析DNS 预解析是指浏览器视图在用户访问链接之前解析域名。那接下来用户如果确实访问了该域名，那 DNS 的解析时间将不会有延迟。浏览器对网站第一次的域名 DNS 查找流程为：浏览器缓存 =&gt; 系统缓存 =&gt; 路由器缓存 =&gt; ISP DNS 缓存 =&gt; DNS 服务器。所以我们不需要对和当前页面中同一个域的域名进行预获取（浏览器会缓存解析结果）。 使用起来也很简单： 1234&#x2F;&#x2F; 如果需要禁用隐式的 DNS prefetch 设置 content &#x3D; &quot;off&quot;&lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot;&gt;&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;ha.aa.bb&quot;&gt;复制代码 HTTP2 &amp;&amp; HTTP1先来一个例子大家直观感受下两者的差异，可以看到 HTTP/2 性能有大幅提高。这里就必须提到其引入的多路复用技术，在这个技术的支持下，同一域名下的所有请求都在一个通道内完成。这也是引入了帧和流的概念，帧是数据最小传输单位，且标记了属于哪个流，流就是多个数据帧组成的数据流。多路复用就是一个连接下存在多个流。而 HTTP/1 中每个请求都必须创建一个 TCP 连接，浏览器还限制了同一个域名下的请求数量，当请求资源较多的时候会出现队头阻塞。 且 HTTP/2 采用二进制传输代替了 HTTP/1 中的文本传输，解析更加高效。 浏览器缓存策略缓存是性能优化中性价比很高的一种优化方式，显著的减少了网络传输带来的损耗。 浏览器的缓存机制有四种，按优先级排列如下： Service Worker Memory Cache Disk Cache Push Cache 当以上都没有命中资源的时候才去做网络请求。 Service WorkerService Worker 是运行在浏览器背后的独立线程，且脱离浏览器窗口，因此无法直接访问 DOM。也正是独立的特点，我们往往可以通过它实现离线缓存，消息推送和网络代理等功能。但由于涉及到网络代理的，使用 Service Worker 时，传输协议必须为 HTTPS。 使用步骤分为三步：注册 Service Worker；监听 install 事件，并缓存需要的文件；在下次请求的时候通过拦截请求的方式查询是否存在缓存，存在的话直接读取缓存文件，否则请求资源。 有一点需要注意的是，当我们没有在 Service Worker 命中缓存，需要调用 fetch 函数获取数据时，浏览器会依次根据缓存优先级继续查找，但此时找到的数据依旧会显示是从 Service Worker 中获取的。 Memory CacheMemory Cache 是指内存中的缓存，是速度非常快的一种缓存。但是虽然读取效率高，其生存时间较短，一旦 Tab 页关闭，内存中的缓存就被释放了。但是具体哪部分内容会被缓存并不确定，需要根据系统内存的具体情况判断。 Disk CacheDisk Cache 是指存在硬盘中的缓存，读取速度较慢，但是时效性较高。即使在跨站点的情况下，相同地址的资源一旦被缓存下来就不会再次去请求数据。 Push CacheHTTP/2 中的内容，不太了解~~有了解的同学可以一起交流下呀 缓存策略前面提到了各种类型的缓存，但是究竟要不要缓存，怎么判断缓存过期时间，这些问题都要从缓存策略中找到答案。 浏览器的缓存策略分为两种：强缓存和协商缓存。 强缓存强缓存的实现依赖 Expires 和 Cache-Control 两个字段来控制。强缓存表示缓存期间不需要再次请求，返回状态码 200。 强缓存的早期实现是靠 Expires 字段，这个字段是一个时间戳，表示在这个事件前的缓存都是有效的。可以看到这个字段十分依赖本地时间，如果修改客户端时间可能就会出问题。 HTTP/1.1 出现的 Cache-Control 可以完全替代 Expires 并提供更丰富的功能。它提供了很多指令： 指令 作用 public 表示响应可以被客户端和代理服务器缓存 private 表示响应只能被客户端缓存 max-age=30 缓存 30 s 后过期 s-maxage=30 覆盖 max-age ，但只在代理服务器中生效 no-store 不缓存任何响应 no-cache 资源被缓存但是立即失效，下次会发起请求验证资源是否过期 max-stale=30 30s 内及时缓存过期也使用该缓存 min-fresh=30 希望在 30s 内获取最新的响应 协商缓存如果缓存过期了或是设置了 no-cache，则进入协商缓存阶段。协商缓存的实现依赖于两个字段：：Etag 以及 Last-modified。当浏览器发起验证请求资源时，如果资源没有改动，就返回 304 状态码，并更新缓存有效期。 当浏览器发起请求时，会带上 If-Modified-Since 字段，它的值是上次请求资源时 Last-modified 提供的时间戳。服务器再判断在这个时间戳之后是否有改动。但是这个机制还是存在弊端的，因为时间戳是以秒为单位计算的，如果再 1s 内的改动是无法被感知到的。 Etag 就是为了解决上述问题出现的，浏览器会将上次请求资源返回结果携带的 Etag 作为 If-None-Match 的值发送给服务器，有变动的话就返回新的资源。Etag 的缺陷在于服务器需要有额外的开销，可能会影响性能。 那当没有设置缓存策略时，浏览器会怎么办？通常会取响应头中的 DATE 减去 Last-modified 值的 10% 作为缓存时间。 实际应用策略大致了解了浏览器缓存机制之后，要怎么利用它们来提高性能呢？这才是我们真正要解决的问题。 对于频繁变动的资源，可以设置 Cache-Control: no-cache ，让浏览器每次都请求服务器验证资源是否有效。如果有效，可以有效减少响应数据大小。 对于一些打包过后的代码文件，比如 webpack ，通常我们都会对文件名做哈希处理，一般只要文件改动过了，文件名就会改动。所以对于这类文件，可以采用强缓存策略，设置较长时间的缓存时间，比如 Cache-Control: max-age=31536000。 构建工具优化减少打包时间 优化 Loader 就拿 Babel 举例，首先优化 Loader 的文件搜索范围，合理利用 test ，include，exclude ；缓存编译过的文件，下次只需要编译更改过的代码即可： 12loader: &#39;babel-loader?cacheDirectory&#x3D;true&#39;复制代码 HappyPack HappyPack 将 loader 的同步执行转换为并行执行 123456789plugins: [ new HappyPack(&#123; id: &#39;happybabel&#39;, loaders: [&#39;babel-loader?cacheDirectory&#39;], &#x2F;&#x2F; 开启 4 个线程 threads: 4 &#125;)]复制代码 DllPlugin DllPlugin 将制定的库提前打包后引入，下次打包时只有当库版本更新后才需要重新打包。 12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; 单独配置在一个文件中&#x2F;&#x2F; webpack.dll.conf.jsconst path &#x3D; require(&#39;path&#39;)const webpack &#x3D; require(&#39;webpack&#39;)module.exports &#x3D; &#123; entry: &#123; &#x2F;&#x2F; 想统一打包的类库 vendor: [&#39;react&#39;] &#125;, output: &#123; path: path.join(__dirname, &#39;dist&#39;), filename: &#39;[name].dll.js&#39;, library: &#39;[name]-[hash]&#39; &#125;, plugins: [ new webpack.DllPlugin(&#123; &#x2F;&#x2F; name 必须和 output.library 一致 name: &#39;[name]-[hash]&#39;, &#x2F;&#x2F; 该属性需要与 DllReferencePlugin 中一致 context: __dirname, path: path.join(__dirname, &#39;dist&#39;, &#39;[name]-manifest.json&#39;) &#125;) ]&#125;&#x2F;&#x2F; 先执行上面的配置文件生成依赖文件，再使用 DllReferencePlugin 将依赖文件引入项目中&#x2F;&#x2F; webpack.conf.jsmodule.exports &#x3D; &#123; plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, &#x2F;&#x2F; manifest 就是之前打包出来的 json 文件 manifest: require(&#39;.&#x2F;dist&#x2F;vendor-manifest.json&#39;), &#125;) ]&#125;复制代码 压缩代码体积 按需加载 在开发 SPA 项目时，比较好的一个实践是，可以使用按需加载将每个路由页面单独打包为一个文件，避免首页加载文件过大，当然对于大型类库也同样适用。 Scope Hoisting 12345&#x2F;&#x2F; a.jsexport const a &#x3D; 1&#x2F;&#x2F; index.jsexport &#123;a&#125; from &#39;.&#x2F;a.js&#39;复制代码 有以上两个文件，使用 webpack打包后会变为： 1234567891011[ &#x2F;* 0 *&#x2F; function (module, exports, require) &#123; &#x2F;&#x2F;... &#125;, &#x2F;* 1 *&#x2F; function (module, exports, require) &#123; &#x2F;&#x2F;... &#125;]复制代码 使用了 Scope Hoisting 之后，代码会尽量合并到一个函数中，变为： 1234567[ &#x2F;* 0 *&#x2F; function (module, exports, require) &#123; &#x2F;&#x2F;... &#125;]复制代码 可以看到代码量会减少很多，我们可以通过在 webpack 中配置 optimization.concatenateModules 来开启 Scope Hoisting。 Tree Shaking Tree Shaking 用于删除应用中未被引用的代码，webpack4 默认开启了这个功能。 图片资源优化web 应用中图片几乎是必不可少的资源，也是十分损耗性能的一个点。图片优化的最好切入点在于根据业务场景做好图片选型方案。 JPG JPG 的特点是有损压缩，体积小，加载快，但不支持透明。所以通常可以用于大的背景图或是轮播图等色彩丰富的图片中。不适用于一些矢量图形或是对比比较鲜明的图片。 PNG PNG 的特点是无损压缩，质量高，体积大。通常用于透明图片，小 LOGO，或是颜色简单但对比强烈的图片。 SVG SVG 的特点是体积小，不失真，兼容性好。一般页面上的图标都可以用 SVG 制作，只是渲染成本较高，对性能可能略有影响。 Base64 Base64 的特点是文本文件，可用于页面上的小图标。 WebP WebP 的特点是支持透明，支持动态图片，支持有损压缩和无损压缩。但是兼容性太差，但是对于兼容 WebP 的浏览器可以尽量多使用。 CSS 很多时候一些效果可以直接通过 CSS 实现，这个时候就大胆的放弃使用图片吧。 预加载 &amp; 预渲染 预加载 12&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&quot;&gt;复制代码 如果页面某些资源可能不会马上用到，但是希望尽早获取，可以使用预加载。它会强制浏览器请求资源，但不会阻塞 onload 事件。预加载可以降低首屏加载时间，因为可以将一些不影响首屏但很重要的文件延后加载。 预渲染 12&lt;link rel&#x3D;&quot;prerender&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&quot;&gt; 复制代码 预渲染是Chrome中的一项功能，可以改善用户可见的页面加载时间。预渲染由引用页面中的 `` 元素触发。为预渲染的URL创建一个隐藏页面，该页面将完全加载所有相关资源，以及执行 JS 文件。如果用户进入该页面，则隐藏页面将被交换到当前选项卡中并使其可见。 懒加载 &amp;&amp; 懒执行 懒加载 大多数人应该都接触过图片懒加载，实际上就是将不关键的资源延后加载。举个例子，当图片没有出现在可视区域内，我们可以先统一用一张占位图来显示，将真实的 src 存入自定义属性中，当进入到到可视区域后，再替换 src 属性。 懒执行 将某些比较耗时的且不需要在首屏中使用的逻辑延后到使用时再计算，一般用于首屏优化中。 CDNCDN 是指一组分布在各个地区的服务器。这些服务器存储数据的副本，因此服务器可以根据那些服务器距离用户最近来满足数据的请求。CDN 适合被用于存放静态资源。 转载自掘金imyjayhttps://juejin.im/post/5ddb6b75f265da7dfb15ec4e","tags":[]},{"title":"前端萌新眼中的Promise及使用","date":"2019-12-27T08:24:42.691Z","path":"2019/12/27/前端萌新眼中的Promise及使用/","text":"前端萌新眼中的Promise及使用 一个 Promise 就是一个代表了异步操作最终完成或者失败的对象。这是MDN上关于Promise的解释。在前端开发中，Promise经常被拿来用于处理异步和回调的问题，来规避回调地狱和更好排布异步相关的代码。本篇文章对于Promise以及相关的async/await记录一些自己的理解和体会。 一、Promise的三种状态从字面的意思理解，Promise即是承诺，既是承诺，那承诺的结果就会有成功和失败两种。而且，我们许下承诺之后不会立即得到结果，在获得成功或是失败的结果之前，我们还需要一点时间来履行这个承诺。Promise的构造其实像极了我们生活中的承诺。 上面这张图就是Promise的结构图。就像我们生活中的承诺一样，Promise也存在三种状态,一种是履行承诺的pending状态，一种是承诺失败时的Rejected状态，再就是承诺成功时Fullfilled状态。 接下来，我们以爱情的名义来承诺一下： 12345678910111213141516171819let love &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F;开始谈恋爱，不过恋爱的结果要以后才知道 let happy &#x3D; Math.random() &gt;&#x3D; 0.3 ? true : false if ( happy ) &#123; resolve(&#39;marry&#39;) &#x2F;&#x2F;恋爱成功，决定结婚 &#125; else &#123; reject(&#39;break&#39;) &#x2F;&#x2F;恋爱失败，决定分手 &#125; &#125;, 500)&#125;)love.then(result &#x3D;&gt; &#123; console.log(result) &#x2F;&#x2F;处理恋爱成功的回调，result是上面resolve传过来的&#39;marry&#39;&#125;).catch(result &#x3D;&gt; &#123; console.log(result) &#x2F;&#x2F;处理恋爱失败的回调，result是上面reject传过来的&#39;break&#39;&#125;)复制代码 上面的代码就是一个简单却完整的Promise的例子。需要特别注意的是，Promise在经过pending状态达到成功或失败状态时就会凝固，即到达成功状态后再也不会失败，失败以后也不会回到成功状态。 所以下面的Promise一定是失败状态的，即便reject后面跟了resolve也没用。正所谓：若爱，请深爱，若弃，请彻底，不要暧昧，伤人伤己。柏拉图这话，说的就是Promise的状态凝固。 1234567891011let love &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; reject(&#39;break&#39;) resolve(&#39;marry&#39;)&#125;)love.then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 二、Promise的then与catch的几种写法第一种，最常见的就是上面的写法, 使用then来捕捉resolve状态，使用catch来捕捉reject状态1234567love.then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 第二种，不写catch, 把用来捕捉reject状态的函数也写到then里，但是效果和上面一样123456love.then(result &#x3D;&gt; &#123; console.log(result)&#125;, result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 第三种，分开写，也是可以的12345678love.then(result &#x3D;&gt; &#123; &#x2F;&#x2F;只捕捉和处理成功状态 console.log(result)&#125;)love.catch(result &#x3D;&gt; &#123; &#x2F;&#x2F;只捕捉和处理失败状态 console.log(result) &#125;)复制代码 三、快速构建一个成功或是失败状态的PromisePromise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise.resolve(), 用于构建成功状态的Promise;另一个是Promise.reject()，用于构建失败状态的Promise。 123456789101112let p1 &#x3D; Promise.resolve(&#39;success&#39;)console.log(p1) &#x2F;&#x2F; 打出来的是 Promise &#123;&#39;success&#39;&#125;p1.then(result &#x3D;&gt; &#123; console.log(result) &#x2F;&#x2F;打出来上面resolve传过来的字符串&#39;success&#39;&#125;)let p2 &#x3D; Promise.reject(&#39;failed&#39;) &#x2F;&#x2F;上面是一个成功状态Promise，这是一失败状态的Promisep2.catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 四、使用Promise.all()来处理一类前端场景在前端的开发实践中，我们有时会遇到需要发送多个请求并根据请求顺序返回数据的需求，比如，我们要发送a、b、c三个请求，这三个请求返回的数据分别为a1、a2、a3，而我们想要a1、a2、a3按照我们希望的顺序返回。那么，使用Promise.all()方法可以完美的解决这一问题。 假设使用代码如下： 123456789101112131415161718192021222324252627&#x2F;&#x2F;模拟异步请求的函数let request &#x3D; (name, time) &#x3D;&gt; &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; let random &#x3D; Math.random() if (random &gt;&#x3D; 0.2) &#123; resolve(&#96;$&#123;name&#125;成功了&#96;) &#125; else &#123; reject(&#96;$&#123;name&#125;失败了&#96;) &#125; &#125;, time) &#125;)&#125;&#x2F;&#x2F;构建三个Promise实例let a &#x3D; request(&#39;小明&#39;, 1000)let b &#x3D; request(&#39;小红&#39;, 500)let c &#x3D; request(&#39;小华&#39;, 1500)&#x2F;&#x2F;使用Promise.all(), 注意它接收的是一个数组作为参数 Promise.all([b,a,c]).then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(result &#x3D;&gt; &#123; console.log(result)&#125;)复制代码 把上面的代码复制下来放到浏览器的调试控制台里多执行几次（第二次执行需要刷新）会发生什么事情呢？你可能猜到了：如果三个请求都成功的话，那么这三个请求所返回的数据就是按照发送请求的顺序排列的，即[‘小红成功了’, ‘小明成功了’, ‘小华成功了’]，而且还是以数组形式返回的；而当其中有请求失败了的话，就只会返回最先失败的结果。 当然，除了这个场景以外，Promise.all()方法还能用于其它地方。比如说，一个页面上有两个请求，只有拿到了这两个请求的数据，页面才会展示，在这之前会显示一个loading加载图。使用Promise.all()也是可以非常简洁的解决这个问题。 五、Promise的链式调用上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。 123456let p &#x3D; Promise.resolve(&#39;success&#39;)let response &#x3D; p.then(result &#x3D;&gt; &#123; console.log(result)&#125;)console.log(response) &#x2F;&#x2F;打出来的response是一个Promise对象复制代码 因为then之后返回的还是一个Promise对象，那我们就可以继续then，只不过后面then拿到的参数是上一个then里return的内容，而这个return的内容既可以是普通的字符串、数字等（最后都会被封装成Promise）也可以是自己写的一个Promise对象。 接下来我们接着上面爱的承诺继续写一个链式调用的例子： 12345678910111213141516171819202122232425262728293031let love &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; let happy &#x3D; Math.random() &gt;&#x3D; 0.3 ? true : false if ( happy ) &#123; resolve(&#39;marry&#39;) &#125; else &#123; reject(&#39;break&#39;) &#125; &#125;, 500)&#125;)let haveChild &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39;孩子生了！&#39;) &#125;, 1000)&#125;)love.then(result &#x3D;&gt; &#123; console.log(result) return haveChild &#x2F;&#x2F; 这里返回一个Promise对象,它的resolve会被下一个then捕捉&#125;).then(result &#x3D;&gt; &#123; console.log(result) return &#39;最后，他们白头偕老！&#39; &#x2F;&#x2F;这里返回的字符串会传给下一个then&#125;).then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(error &#x3D;&gt; &#123; console.log(error)&#125;)复制代码 这里需要注意的是，在链式调用的最一定要加上一个catch来捕捉链条中可能出现的错误！ 六、Promise链式调用可以处理的一个业务场景当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了。 我们使用axios来演示，axios本身就使用Promise进行封装，代码如下： 12345678910111213141516let request &#x3D; (url) &#x3D;&gt; &#123; let result &#x3D; axios.get(url) &#x2F;&#x2F;result是Promise对象 result.then(response &#x3D;&gt; &#123; return response &#125;).catch(error &#x3D;&gt; &#123; throw new Error(&#39;出错了!&#39;) &#125;)&#125;request(url0).then(response &#x3D;&gt; &#123; return request(response.data.link)&#125;).then(result &#x3D;&gt; &#123; console.log(result)&#125;).catch(error &#x3D;&gt; &#123; console.log(error)&#125;)","tags":[]},{"title":"V8引擎垃圾内存回收原理解析","date":"2019-12-27T01:53:43.558Z","path":"2019/12/27/V8引擎垃圾内存回收原理解析/","text":"V8 引擎垃圾内存回收原理解析JS 语言不像 C/C++, 让程序员自己去开辟或者释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。 作为一名资深的前端工程师，对于JS内存回收的机制是需要非常清楚，以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习 这其中的机制，也对我们深入理解JS的闭包特性、以及对内存的高效使用，都有很大的帮助。 V8 内存限制在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，在64位系统下， V8最多只能分配1.4G, 在 32 位系统中，最多只能分配0.7G。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到 一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。 我们知道对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析 堆内存的垃圾回收。 所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存 已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。 那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？ 究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。 首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的: 以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。 可见其耗时之久，而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的 选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。 不过，如果你想调整这个内存的限制也不是不行。配置命令如下: 12&#x2F;&#x2F; 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存node --max-old-space-size&#x3D;2048 xxx.js 或者 12&#x2F;&#x2F; 这是调整新生代这部分的内存，单位是 KB。node --max-new-space-size&#x3D;2048 xxx.js 新生代内存的回收V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存 之和。 根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。 首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好 理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。 那好了，新生代的垃圾回收是怎么做的呢？ 首先将新生代内存空间一分为二: 其中From部分表示正在使用的内存，To 是目前闲置的内存。 当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。 当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。 那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？ 注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景: 16e62eaf5946cfc5 深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配， 这种零散的空间也叫做内存碎片。刚刚介绍的新生代垃圾回收算法也叫Scavenge算法。 Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子: 是不是整齐了许多？这样就大大方便了后续连续空间的分配。 不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。 老生代内存的回收刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。 发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升: 已经经历过一次 Scavenge 回收。 To（闲置）空间的内存占用超过25%。 现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用Scavenge算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是 劳民伤财？ 那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？ 第一步，进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象， 对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。 当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？ 第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。 16e62eb43245357f 由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。 增量标记由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。 那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就”歇”一下，就js应用逻辑执行一会儿， 然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。 经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。 JS垃圾回收的原理就介绍到这里了，其实理解起来是非常简单的，重要的是理解它为什么要这么做，而不仅仅是如何做的，希望这篇总结能够对你有所启发","tags":[]},{"title":"Vue相关问题(一)","date":"2019-12-26T09:53:10.202Z","path":"2019/12/26/Vue相关问题(一)/","text":"1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 2、v-show 与 v-if 有什么区别？v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div v-bind:class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;&#x2F;div&gt;data: &#123; isActive: true, hasError: false&#125; 数组语法： 123456&lt;div v-bind:class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt;data: &#123; activeClass: &#39;active&#39;, errorClass: &#39;text-danger&#39;&#125; Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div v-bind:style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;data: &#123; activeColor: &#39;red&#39;, fontSize: 30&#125; 数组语法： 12345678910&lt;div v-bind:style&#x3D;&quot;[styleColor, styleSize]&quot;&gt;&lt;&#x2F;div&gt;data: &#123; styleColor: &#123; color: &#39;red&#39; &#125;, styleSize:&#123; fontSize:&#39;23px&#39; &#125;&#125; 4、怎样理解 Vue 的单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 123456props: [&#39;initialCounter&#39;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 123456props: [&#39;size&#39;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 5、computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6、直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： 123456&#x2F;&#x2F; Vue.setVue.set(vm.items, indexOfItem, newValue)&#x2F;&#x2F; vm.$set，Vue.set的一个别名vm.$set(vm.items, indexOfItem, newValue)&#x2F;&#x2F; Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 为了解决第二个问题，Vue 提供了以下操作方法： 12&#x2F;&#x2F; Array.prototype.splicevm.items.splice(newLength) 7、谈谈你对 Vue 生命周期的理解？（1）生命周期是什么？ Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 （2）各个生命周期的作用 生命周期 描述 beforeCreate 组件实例被创建之初，组件的属性生效之前 created 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update 组件数据更新之后 activited keep-alive 专属，组件被激活时调用 deadctivated keep-alive 专属，组件被销毁时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 （3）生命周期示意图 ![1.png](data:image/svg+xml;utf8,) 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程 父 beforeUpdate -&gt; 父 updated 销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 9、在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 10、在什么阶段才能访问操作DOM？在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。 ![1.png](data:image/svg+xml;utf8,) 11、父组件可以监听到子组件的生命周期吗？比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： 1234567&#x2F;&#x2F; Parent.vue&lt;Child @mounted&#x3D;&quot;doSomething&quot;&#x2F;&gt; &#x2F;&#x2F; Child.vuemounted() &#123; this.$emit(&quot;mounted&quot;);&#125; 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： 123456789101112131415&#x2F;&#x2F; Parent.vue&lt;Child @hook:mounted&#x3D;&quot;doSomething&quot; &gt;&lt;&#x2F;Child&gt;doSomething() &#123; console.log(&#39;父组件监听到 mounted 钩子函数 ...&#39;);&#125;, &#x2F;&#x2F; Child.vuemounted()&#123; console.log(&#39;子组件触发 mounted 钩子函数 ...&#39;);&#125;, &#x2F;&#x2F; 以上输出顺序为：&#x2F;&#x2F; 子组件触发 mounted 钩子函数 ...&#x2F;&#x2F; 父组件监听到 mounted 钩子函数 ... 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 12、谈谈你对 keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 13、组件中 data 为什么是一个函数？ 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 123456789101112131415&#x2F;&#x2F; datadata() &#123; return &#123; message: &quot;子组件&quot;, childName:this.name &#125;&#125;&#x2F;&#x2F; new Vuenew Vue(&#123; el: &#39;#app&#39;, router, template: &#39;&lt;App&#x2F;&gt;&#39;, components: &#123;App&#125;&#125;) 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 14、v-model 的原理？我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 12345&lt;input v-model&#x3D;&#39;something&#39;&gt; 相当于&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt; 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 1234567891011121314父组件：&lt;ModelChild v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ModelChild&gt;子组件：&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;div&gt;props:&#123; value: String&#125;,methods: &#123; test1()&#123; this.$emit(&#39;input&#39;, &#39;小红&#39;) &#125;,&#125;, 15、Vue 组件间通信有哪几种方式？Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。 （1）props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 （2）ref 与 $parent / $children 适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 （3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （4）$attrs/$listeners 适用于 隔代组件通信 $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件 （5）provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （6）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 16、你使用过 Vuex 吗？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 17、使用过 Vue SSR 吗？说说 SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下： （1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。 18、vue-router 路由模式有几种？vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： 123456789101112131415switch (mode) &#123; case &#39;history&#39;: this.history &#x3D; new HTML5History(this, options.base) break case &#39;hash&#39;: this.history &#x3D; new HashHistory(this, options.base, this.fallback) break case &#39;abstract&#39;: this.history &#x3D; new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123; assert(false, &#96;invalid mode: $&#123;mode&#125;&#96;) &#125;&#125; 其中，3 种路由模式的说明如下： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？（1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： 1https:&#x2F;&#x2F;www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 12window.history.pushState(null, null, path);window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 20、什么是 MVVM？Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表 MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示： （1）View 层 View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然： （1）View 层 1234&lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt;Click me&lt;&#x2F;button&gt;&lt;&#x2F;div&gt; （2）ViewModel 层 12345678910111213141516171819202122var app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; &#x2F;&#x2F; 用于描述视图状态 message: &#39;Hello Vue!&#39;, &#125;, methods: &#123; &#x2F;&#x2F; 用于描述视图行为 showMessage()&#123; let vm &#x3D; this; alert(vm.message); &#125; &#125;, created()&#123; let vm &#x3D; this; &#x2F;&#x2F; Ajax 获取 Model 层的数据 ajax(&#123; url: &#39;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&#39;, success(res)&#123; vm.message &#x3D; res; &#125; &#125;); &#125;&#125;) （3） Model 层 12345678&#123; &quot;url&quot;: &quot;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&quot;, &quot;res&quot;: &#123; &quot;success&quot;: true, &quot;name&quot;: &quot;IoveC&quot;, &quot;domain&quot;: &quot;www.cnblogs.com&quot; &#125;&#125; 21、Vue 是如何实现数据双向绑定的？即： 输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。 其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。 Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 22、Vue 框架怎么实现对象和数组的监听？如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下： 12345678910111213&#x2F;** * Observe a list of Array items. *&#x2F;observeArray (items: Array&lt;any&gt;) &#123; for (let i &#x3D; 0, l &#x3D; items.length; i &lt; l; i++) &#123; observe(items[i]) &#x2F;&#x2F; observe 功能为监测数据的变化 &#125;&#125;&#x2F;** * 对属性进行递归遍历 *&#x2F;let childOb &#x3D; !shallow &amp;&amp; observe(val) &#x2F;&#x2F; observe 功能为监测数据的变化 通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。 23、Proxy 与 Object.defineProperty 优劣对比Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？ 12345678910111213141516171819202122232425export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; &#x2F;&#x2F; target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; &#x2F;&#x2F; 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length &#x3D; Math.max(target.length, key) &#x2F;&#x2F; 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val &#125; &#x2F;&#x2F; key 已经存在，直接修改属性值 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] &#x3D; val return val &#125; const ob &#x3D; (target: any).__ob__ &#x2F;&#x2F; target 本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] &#x3D; val return val &#125; &#x2F;&#x2F; 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val&#125; 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 25、虚拟 DOM 的优缺点？优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 26、虚拟 DOM 实现原理？虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 27、Vue 中的 key 有什么作用？key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： 123456789function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map &#x3D; &#123;&#125; for (i &#x3D; beginIdx; i &lt;&#x3D; endIdx; ++i) &#123; key &#x3D; children[i].key if (isDef(key)) map[key] &#x3D; i &#125; return map&#125; 28、你有对 Vue 项目进行哪些优化？（1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 29、对于即将到来的 vue3.0 特性你有什么了解的吗？Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性： （1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 新的 observer 还提供了以下特性： 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。 （2）模板 模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （3）对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。 此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。 （4）其它方面的更改 vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改： 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。","tags":[]},{"title":"Vue代理proxyTable设置","date":"2019-12-26T09:40:01.198Z","path":"2019/12/26/Vue代理proxyTable设置/","text":"Vue 代理 proxyTable 设置背景：vue项目在本地开发默认打开localhost:8081，但是后端请求地址和本地产生跨域，怎样快速的在本地进行调接口调试？vue-cli自带的proxyTable 可以解决本地开发跨域问题 我们在项目中的后端路由，都带有 /server/ 的prefix 那么我们在config里配置 proxyTable 可以这样写： 123456789proxyTable: &#123; &#39;&#x2F;server&#39;: &#123; target: &#39;http:&#x2F;&#x2F;后端地址:7002&#39;, changeOrigin: true, pathRewrite: &#123; &#39;&#x2F;server&#39;: &#39;&#x2F;server&#x2F;&#39; &#125; &#125; &#125;, 这样本地就可以调用后端的接口进行调试了，记住，改完config文件要重新npm run dev ps：此方法仅限用于开发环境，不适合生产环境，生产环境可以用nginx进行代理","tags":[]},{"title":"JavaScript执行机制","date":"2019-12-26T09:35:01.855Z","path":"2019/12/26/JavaScript执行机制/","text":"1.关于javascriptjavascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ 2.javascript事件循环既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明： 导图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 说了这么多文字，不如直接一段代码更直白： 123456789let data &#x3D; [];$.ajax(&#123; url:www.javascript.com, data:data, success:() &#x3D;&gt; &#123; console.log(&#39;发送成功!&#39;); &#125;&#125;)console.log(&#39;代码执行结束&#39;); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。 3.又爱又恨的setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行： 123setTimeout(() &#x3D;&gt; &#123; console.log(&#39;延时3秒&#39;);&#125;,3000) 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？ 先看一个例子： 1234setTimeout(() &#x3D;&gt; &#123; task();&#125;,3000)console.log(&#39;执行console&#39;); 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是： 12&#x2F;&#x2F;执行console&#x2F;&#x2F;task() 去验证一下，结果正确！然后我们修改一下前面的代码： 12345setTimeout(() &#x3D;&gt; &#123; task()&#125;,3000)sleep(10000000) 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明： 12345678910&#x2F;&#x2F;代码1console.log(&#39;先执行这里&#39;);setTimeout(() &#x3D;&gt; &#123; console.log(&#39;执行啦&#39;)&#125;,0);&#x2F;&#x2F;代码2console.log(&#39;先执行这里&#39;);setTimeout(() &#x3D;&gt; &#123; console.log(&#39;执行啦&#39;)&#125;,3000); 代码1的输出结果是： 12&#x2F;&#x2F;先执行这里&#x2F;&#x2F;执行啦 代码2的输出结果是： 123&#x2F;&#x2F;先执行这里&#x2F;&#x2F; ... 3s later&#x2F;&#x2F; 执行啦 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。 4.又恨又爱的setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。 5.Promise与process.nextTick(callback)传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。 Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promise。而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明： 1234567891011setTimeout(function() &#123; console.log(&#39;setTimeout&#39;);&#125;)new Promise(function(resolve) &#123; console.log(&#39;promise&#39;);&#125;).then(function() &#123; console.log(&#39;then&#39;);&#125;)console.log(&#39;console&#39;); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 事件循环，宏任务，微任务的关系如图所示： 我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制： 123456789101112131415161718192021222324252627282930313233343536console.log(&#39;1&#39;);setTimeout(function() &#123; console.log(&#39;2&#39;); process.nextTick(function() &#123; console.log(&#39;3&#39;); &#125;) new Promise(function(resolve) &#123; console.log(&#39;4&#39;); resolve(); &#125;).then(function() &#123; console.log(&#39;5&#39;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&#39;6&#39;);&#125;)new Promise(function(resolve) &#123; console.log(&#39;7&#39;); resolve();&#125;).then(function() &#123; console.log(&#39;8&#39;)&#125;)setTimeout(function() &#123; console.log(&#39;9&#39;); process.nextTick(function() &#123; console.log(&#39;10&#39;); &#125;) new Promise(function(resolve) &#123; console.log(&#39;11&#39;); resolve(); &#125;).then(function() &#123; console.log(&#39;12&#39;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 宏任务Event Queue 微任务Event Queue setTimeout2 process2 then2 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 宏任务Event Queue 微任务Event Queue process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 6.写在最后(1)js的异步我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。 (2)事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 (3)javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。 (4)setImmediate微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。 (5)最后的最后 javascript是一门单线程语言 Event Loop是javascript的执行机制","tags":[]},{"title":"项目常用JS方法封装","date":"2019-12-26T09:27:13.336Z","path":"2019/12/26/项目常用JS方法封装/","text":"001.输入一个值,返回其数据类型1234type &#x3D; para &#x3D;&gt; &#123; return Object.prototype.toString.call(para).slice(8,-1) &#125;qwe 002.冒泡排序升序 bubbleAsSort() 12345678910111213bubbleAsSort &#x3D; arr &#x3D;&gt; &#123; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; for (let j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp &#x3D; arr[j + 1]; arr[j + 1] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125; &#125; return arr;&#125;qwe 降序 bubbleDeSort() 12345678910111213bubbleDeSort &#x3D; arr &#x3D;&gt; &#123; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; for (let j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; let temp &#x3D; arr[j + 1]; arr[j + 1] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125; &#125; return arr;&#125;qwe 003.选择排序升序 selectAsSort() 12345678910111213141516selectAsSort &#x3D; arr &#x3D;&gt; &#123; let minIndex, temp; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; minIndex &#x3D; i; for (let j &#x3D; i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex &#x3D; j; &#125; &#125; temp &#x3D; arr[i]; arr[i] &#x3D; arr[minIndex]; arr[minIndex] &#x3D; temp; &#125; return arr;&#125;qwe 降序 selectDeSort() 12345678910111213141516selectDeSort &#x3D; arr &#x3D;&gt; &#123; let minIndex, temp; for (let i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; minIndex &#x3D; i; for (let j &#x3D; i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &gt; arr[minIndex]) &#123; minIndex &#x3D; j; &#125; &#125; temp &#x3D; arr[i]; arr[i] &#x3D; arr[minIndex]; arr[minIndex] &#x3D; temp; &#125; return arr;&#125;qwe 004.插入排序升序 insertAsSort() 1234567891011121314insertAsSort &#x3D; arr &#x3D;&gt; &#123; let current, preIndex; for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; current &#x3D; arr[i]; preIndex &#x3D; i - 1; while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] &#x3D; arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] &#x3D; current; &#125; return arr;&#125;qwe 降序 insertDeSort() 1234567891011121314insertDeSort &#x3D; arr &#x3D;&gt; &#123; let current, preIndex; for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; current &#x3D; arr[i]; preIndex &#x3D; i - 1; while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &lt; current) &#123; arr[preIndex + 1] &#x3D; arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] &#x3D; current; &#125; return arr;&#125;qwe 005.阶乘12345678factorial &#x3D; num &#x3D;&gt; &#123; let count &#x3D; 1; for (let i &#x3D; 1; i &lt;&#x3D; num; i++) &#123; count *&#x3D; i; &#125; return count;&#125;qwe 006.两个数之间累乘12345678910111213141516multBetride &#x3D; (x, y) &#x3D;&gt; &#123; let count; if (x &lt; y) &#123; count &#x3D; x; for (let i &#x3D; x + 1; i &lt;&#x3D; y; i++) &#123; count *&#x3D; i; &#125; return count; &#125; else &#123; count &#x3D; y; for (let i &#x3D; y + 1; i &lt;&#x3D; x; i++) &#123; count *&#x3D; i; &#125; return count; &#125;&#125; 007.累加（）里面可以放N个实参 1234567function cumsum() &#123; let sum &#x3D; 0; for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123; sum +&#x3D; arguments[i]; &#125; return sum;&#125; 008.计时器(计算代码块(函数)执行时间)无参 computeTime(f) 1234567computeTime &#x3D; code &#x3D;&gt; &#123; let startTime &#x3D; new Date().getTime(); code(); let endTime &#x3D; new Date().getTime(); let time &#x3D; endTime - startTime; return time;&#125; 有参 computeTime(f) 使用方法:computeTime(f,参数1,参数2……) 1234567891011computeTime &#x3D; f &#x3D;&gt; &#123; let startTime &#x3D; new Date().getTime(); let p &#x3D; []; for (let i &#x3D; 1; i &lt; arguments.length; i++) &#123; p.push(arguments[i]) &#125; f.apply(null, p) let endTime &#x3D; new Date().getTime(); let Time &#x3D; endTime - startTime; return Time;&#125; 009.数组去重12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152arrDemp1 &#x3D; arr &#x3D;&gt; &#123; let newArr &#x3D; []; let m &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; let n &#x3D; arr[i]; if (m[n]) &#123; &#125; else &#123; newArr.push(arr[i]); m[n] &#x3D; true; &#125; &#125; return newArr;&#125;&#x2F;&#x2F;遍历数组法arrDemp2 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F;indexOf()方法可返回某个指定的字符串或数组值在字符串或数组中首次出现的位置，若不在其中则返回-1 if (temp.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) temp.push(arr[i]); &#125; return temp;&#125;&#x2F;&#x2F;排序法arrDemp3 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; arr.sort(); temp.push(arr[0]); &#x2F;&#x2F;因为数组已经经过排序，所以重复元素一定相邻，判断当前数组第i个元素与temp的最后一个元素是否相等，不相等时才复制元素 for (let i &#x3D; 1; i &lt; arr.length; i++) &#123; if (arr[i] !&#x3D; temp[temp.length - 1]) temp.push(arr[i]); &#125; return temp;&#125;&#x2F;&#x2F;对象法arrDemp4 &#x3D; arr &#x3D;&gt; &#123; let temp &#x3D; []; let json &#x3D; &#123;&#125;; &#x2F;&#x2F;将当前数组的元素值当作对象的属性，遍历数组，比对对象，如果对象的这个属性不存在则将当前数组元素复制到临时数组，并添加该属性且将属性值赋值为1 for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (!json[arr[i]]) &#123;&#x2F;&#x2F;如果对象没有该属性 temp.push(arr[i]); json[arr[i]] &#x3D; 1;&#x2F;&#x2F;添加属性，将属性值赋值为1 &#125; &#125; return temp;&#125; 也可以使用ES6中的new Set，一步到位 1234let arr &#x3D; [1,2,3,5,4,5,4,3,6]let arrDemp &#x3D; new Set(arr) &#x2F;&#x2F;arrDemp是一个对象let newArr &#x3D; [...arrDemp] &#x2F;&#x2F;把arrDemp转化成数组console.log(newArr); 010.数组对象去重将对象数组中属性相同的项去重 1234567891011121314151617181920212223242526272829303132333435&#x2F;** objArr 对象数组* para 将要进行去重的字段(String类型)*&#x2F;测试数据：let objArr &#x3D; [&#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;a&#39;, age: 2 &#125;, &#123; name: &#39;b&#39;, age: 2 &#125;]console.log(objArrDemp1(objArr,&#39;name&#39;)); &#x2F;&#x2F; [ &#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;b&#39;, age: 2 &#125; ]console.log(objArrDemp1(objArr,&#39;age&#39;)); &#x2F;&#x2F; [ &#123; name: &#39;a&#39;, age: 1 &#125;, &#123; name: &#39;a&#39;, age: 2 &#125; ]objArrDemp1 &#x3D; (objArr, para) &#x3D;&gt; &#123; let result &#x3D; []; let temp &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; objArr.length; i++) &#123; let parameter &#x3D; objArr[i][para]; if (temp[parameter]) &#123; continue;&#x2F;&#x2F;不继续执行接下来的代码，跳转至循环开头 &#125; temp[parameter] &#x3D; true;&#x2F;&#x2F;为temp添加此属性（parameter）且将其值赋为true result.push(objArr[i]);&#x2F;&#x2F;将这一项复制到结果数组result中去 &#125; return result;&#125;objArrDemp2 &#x3D; (objArr, para) &#x3D;&gt; &#123; let hash &#x3D; &#123;&#125;; &#x2F;&#x2F;reduce方法有两个参数，第一个参数是一个callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。 objArr &#x3D; objArr.reduce(function (item, next) &#123;&#x2F;&#x2F;这是针对数组项操作的函数，对于每个数组项，reduce方法都会将其调用一次 hash[next[para]] ? &#39;&#39; : hash[next[para]] &#x3D; true &amp;&amp; item.push(next); return item; &#125;, []);&#x2F;&#x2F;初始值是一个空对象，使用reduce方法返回的是空对象通过叠加执行之后的结果 return objArr;&#125; 011.统计数组中各个元素出现的次数12345678910111213141516staArrNum &#x3D; arr &#x3D;&gt; &#123; let obj &#x3D; &#123;&#125;; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; let m &#x3D; arr[i]; if (obj.hasOwnProperty(m)) &#123; obj[m] +&#x3D; 1; &#125; else &#123; obj[m] &#x3D; 1; &#125; &#125; return obj;&#125;let arr &#x3D; [1, 2, 3, 6, 5, 3, 2, 1, 2, 3, 2, 1]console.log(staArrNum(arr)); &#x2F;&#x2F; &#123; &#39;1&#39;: 3, &#39;2&#39;: 4, &#39;3&#39;: 3, &#39;5&#39;: 1, &#39;6&#39;: 1 &#125; 012.在数组中找指定的元素,返回下标12345678910111213arrFinNum &#x3D; function (arr,num) &#123; let index &#x3D; -1; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (num &#x3D;&#x3D; arr[i]) &#123; index &#x3D; i; break; &#125; &#125; return index;&#125;let arr &#x3D; [1,2,3,4,5,6]console.log(arrFinNum(arr,4)); &#x2F;&#x2F; 3 013.删除数组中的元素123456delArrNum &#x3D; (arr,val) &#x3D;&gt; &#123; let index &#x3D; arrFinNum(arr, val) &#x2F;&#x2F;调用了前面自行添加的arrFinNum方法 if (index !&#x3D; -1) &#123; return arr.splice(index, 1); &#125;&#125; 示例 123456789101112131415161718192021let arr &#x3D; [1, 2, 3, 4, 5, 6]arrFinNum &#x3D; (arr, num) &#x3D;&gt; &#123; let index &#x3D; -1; for (let i &#x3D; 0; i &lt; arr.length; i++) &#123; if (num &#x3D;&#x3D; arr[i]) &#123; index &#x3D; i; break; &#125; &#125; return index;&#125;delArrNum &#x3D; (arr,val) &#x3D;&gt; &#123; let index &#x3D; arrFinNum(arr, val) &#x2F;&#x2F;调用了前面自行添加的arrFinNum方法 if (index !&#x3D; -1) &#123; return arr.splice(index, 1); &#125;&#125;console.log(delArrNum(arr,2)); &#x2F;&#x2F; [ 2 ] 014.数字超过9显示省略号12345678num_filter &#x3D; val &#x3D;&gt;&#123; val &#x3D; val?val-0:0; if (val &gt; 9 ) &#123; return &quot;…&quot; &#125;else&#123; return val; &#125;&#125; 015.数字超过99显示99+12345678ninenum_filter &#x3D; val &#x3D;&gt;&#123; val &#x3D; val?val-0:0; if (val &gt; 99 ) &#123; return &quot;99+&quot; &#125;else&#123; return val; &#125;&#125; 016.银行卡号分割12345bank_filter &#x3D; val &#x3D;&gt;&#123; val +&#x3D; &#39;&#39;; val &#x3D; val.replace(&#x2F;(\\s)&#x2F;g,&#39;&#39;).replace(&#x2F;(\\d&#123;4&#125;)&#x2F;g,&#39;$1 &#39;).replace(&#x2F;\\s*$&#x2F;,&#39;&#39;); return val;&#125; 017.二分查找1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F;非递归实现binarySearch &#x3D; (arr, key) &#x3D;&gt; &#123; let high &#x3D; arr.length - 1, low &#x3D; 0; while (low &lt;&#x3D; high) &#123; let m &#x3D; Math.floor((high + low) &#x2F; 2); if (arr[m] &#x3D;&#x3D; key) &#123; return m; &#125; if (key &gt; arr[m]) &#123; low &#x3D; m + 1; &#125; else &#123; high &#x3D; m - 1; &#125; &#125; return false;&#125;let arr &#x3D; [-1, 1, 3, 4, 5, 8, 32, 234, 12, 42];console.log(binarySearch(arr, 4));&#x2F;&#x2F;递归实现binarySearch &#x3D; (arr, low, high, key) &#x3D;&gt; &#123; if (low &gt; high) &#123; return -1; &#125; let mid &#x3D; parseInt((high + low) &#x2F; 2); if (arr[mid] &#x3D;&#x3D; key) &#123; return mid; &#125; else if (arr[mid] &gt; key) &#123; high &#x3D; mid - 1; return binarySearch(arr, low, high, key); &#125; else if (arr[mid] &lt; key) &#123; low &#x3D; mid + 1; return binarySearch(arr, low, high, key); &#125;&#125;;let arr &#x3D; [-1, 1, 3, 4, 5, 8, 32, 234, 12, 42];console.log(binarySearch(arr, 0, 13, 5)); 018.防抖与节流123456789101112131415161718192021222324252627282930313233343536373839&#x2F;** * 函数防抖 (只执行最后一次点击) *&#x2F;Debounce &#x3D; (fn, t) &#x3D;&gt; &#123; let delay &#x3D; t || 500; let timer; return function () &#123; let args &#x3D; arguments; if(timer)&#123; clearTimeout(timer); &#125; timer &#x3D; setTimeout(() &#x3D;&gt; &#123; timer &#x3D; null; fn.apply(this, args); &#125;, delay); &#125;&#125;;&#x2F;* * 函数节流 *&#x2F;Throttle &#x3D; (fn, t) &#x3D;&gt; &#123; let last; let timer; let interval &#x3D; t || 500; return function () &#123; let args &#x3D; arguments; let now &#x3D; +new Date(); if (last &amp;&amp; now - last &lt; interval) &#123; clearTimeout(timer); timer &#x3D; setTimeout(() &#x3D;&gt; &#123; last &#x3D; now; fn.apply(this, args); &#125;, interval); &#125; else &#123; last &#x3D; now; fn.apply(this, args); &#125; &#125;&#125;; 019.深拷贝1234567891011121314151617181920212223242526272829deepClone &#x3D; source &#x3D;&gt; &#123; const targetObj &#x3D; source.constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;; &#x2F;&#x2F; 判断复制的目标是数组还是对象 for (let keys in source) &#123; &#x2F;&#x2F; 遍历目标 if (source.hasOwnProperty(keys)) &#123; if (source[keys] &amp;&amp; typeof source[keys] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123; &#x2F;&#x2F; 如果值是对象，就递归一下 targetObj[keys] &#x3D; source[keys].constructor &#x3D;&#x3D;&#x3D; Array ? [] : &#123;&#125;; targetObj[keys] &#x3D; deepClone(source[keys]); &#125; else &#123; &#x2F;&#x2F; 如果不是，就直接赋值 targetObj[keys] &#x3D; source[keys]; &#125; &#125; &#125; return targetObj;&#125;let str1 &#x3D; &#123; arr: [1, 2, 3], obj: &#123; key: &#39;value&#39; &#125;, fn: function () &#123; return 1; &#125;&#125;;let str3 &#x3D; deepClone(str1);console.log(str3 &#x3D;&#x3D;&#x3D; str1); &#x2F;&#x2F; falseconsole.log(str3.obj &#x3D;&#x3D;&#x3D; str1.obj); &#x2F;&#x2F; falseconsole.log(str3.fn &#x3D;&#x3D;&#x3D; str1.fn); &#x2F;&#x2F; true 020.获取视口尺寸需要在HTML文件中运行 1234567891011121314151617181920212223function getViewportOffset() &#123; if (window.innerWidth) &#123; return &#123; w: window.innerWidth, h: window.innerHeight &#125; &#125; else &#123; &#x2F;&#x2F; ie8及其以下 if (document.compatMode &#x3D;&#x3D;&#x3D; &quot;BackCompat&quot;) &#123; &#x2F;&#x2F; 怪异模式 return &#123; w: document.body.clientWidth, h: document.body.clientHeight &#125; &#125; else &#123; &#x2F;&#x2F; 标准模式 return &#123; w: document.documentElement.clientWidth, h: document.documentElement.clientHeight &#125; &#125; &#125;&#125; 021.数字前补零1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;*** num为你想要进行填充的数字* length为你想要的数字长度*&#x2F;&#x2F;&#x2F;迭代方式实现padding1&#x3D;(num, length)&#x3D;&gt; &#123; for(let len &#x3D; (num + &quot;&quot;).length; len &lt; length; len &#x3D; num.length) &#123; num &#x3D; &quot;0&quot; + num; &#125; return num;&#125;&#x2F;&#x2F;递归方式实现padding2&#x3D;(num, length) &#x3D;&gt;&#123; if((num + &quot;&quot;).length &gt;&#x3D; length) &#123; return num; &#125; return padding2(&quot;0&quot; + num, length)&#125;&#x2F;&#x2F;转为小数padding3&#x3D;(num, length)&#x3D;&gt; &#123; let decimal &#x3D; num &#x2F; Math.pow(10, length); &#x2F;&#x2F;toFixed指定保留几位小数 decimal &#x3D; decimal.toFixed(length) + &quot;&quot;; return decimal.substr(decimal.indexOf(&quot;.&quot;)+1);&#125;&#x2F;&#x2F;填充截取法padding4&#x3D;(num, length)&#x3D;&gt; &#123; &#x2F;&#x2F;这里用slice和substr均可 return (Array(length).join(&quot;0&quot;) + num).slice(-length);&#125;&#x2F;&#x2F;填充截取法padding5&#x3D;(num, length)&#x3D;&gt; &#123; let len &#x3D; (num + &quot;&quot;).length; let diff &#x3D; length+1 - len; if(diff &gt; 0) &#123; return Array(diff).join(&quot;0&quot;) + num; &#125; return num;&#125; 022.字符替换可以替换任意数字和符号 12345678910111213&#x2F;*** str 表示将要替换的字符串* l 表示你将要替换的字符* r 表示你想要替换的字符*&#x2F;transFormat &#x3D; (str, l, r) &#x3D;&gt; &#123; let reg &#x3D; new RegExp(l, &#39;g&#39;) &#x2F;&#x2F; g表示全部替换，默认替换第一个 str &#x3D; str.replace(reg, r) return str&#125;console.log(transFormat(&#39;2019-12-13&#39;, &#39;-&#39;, &#39;&#x2F;&#39;)); &#x2F;&#x2F; 2019&#x2F;12&#x2F;13console.log(transFormat(&#39;2019-12-13&#39;, &#39;-&#39;, &#39;&#39;)); &#x2F;&#x2F; 20191213 023.在字符串指定位置插入字符1234567891011&#x2F;*** character 原字符串（String）* site 要插入的字符的位置 （Number）* newStr 想要插入的字符 （String）*&#x2F;insertStr &#x3D; (character, site, newStr) &#x3D;&gt; &#123; return character.slice(0, site) + newStr + character.slice(site);&#125;console.log(insertStr(&#39;20191217&#39;,4,&#39;-&#39;)); &#x2F;&#x2F; 2019-1217 024.字符串反转处理分割123456789101112&#x2F;*** str 是你将要进行处理的字符串(String)* under 是你根据什么字符处理(String)* event 是你根据什么字符把处理结果分割(String)*&#x2F;keyCharacterMap &#x3D; (str,under,event) &#x3D;&gt; &#123; return str.split(under).reverse().join(event)&#125;console.log(keyCharacterMap(&#39;hello world&#39;,&#39;&#39;,&#39;&#39;)); &#x2F;&#x2F; dlrow ollehconsole.log(keyCharacterMap(&#39;hello world&#39;,&#39; &#39;,&#39;-&#39;)); &#x2F;&#x2F; world-hello 025.格式转换：base64转file1234567891011121314151617&#x2F;*** base64 base64* filename 转换后的文件名*&#x2F;base64ToFile &#x3D; (base64, filename) &#x3D;&gt; &#123; let arr &#x3D; base64.split(&quot;,&quot;), mime &#x3D; arr[0].match(&#x2F;:(.*?);&#x2F;)[1], bstr &#x3D; atob(arr[1]), n &#x3D; bstr.length, u8arr &#x3D; new Uint8Array(n); while (n--) &#123; u8arr[n] &#x3D; bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123; type: mime &#125;);&#125; 026.格式转换：base64转blob1234567891011base64ToBlob &#x3D; base64 &#x3D;&gt; &#123; let arr &#x3D; base64.split(&#39;,&#39;), mime &#x3D; arr[0].match(&#x2F;:(.*?);&#x2F;)[1], bstr &#x3D; atob(arr[1]), n &#x3D; bstr.length, u8arr &#x3D; new Uint8Array(n); while (n--) &#123; u8arr[n] &#x3D; bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123; type: mime &#125;);&#125;; 027.格式转换：blob转file12345blobToFile &#x3D; (blob, fileName) &#x3D;&gt; &#123; blob.lastModifiedDate &#x3D; new Date(); blob.name &#x3D; fileName; return blob;&#125;;","tags":[]}]